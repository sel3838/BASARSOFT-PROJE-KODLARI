import CanvasBuilderGroup from"../../render/canvas/BuilderGroup.js";import CanvasExecutorGroup,{DECLUTTER}from"../../render/canvas/ExecutorGroup.js";import CanvasTileLayerRenderer from"./TileLayer.js";import TileState from"../../TileState.js";import ViewHint from"../../ViewHint.js";import ZIndexContext from"../../render/canvas/ZIndexContext.js";import{HIT_DETECT_RESOLUTION,createHitDetectionImageData,hitDetect}from"../../render/canvas/hitdetect.js";import{apply as applyTransform,create as createTransform,multiply,reset as resetTransform,scale,scale as scaleTransform,translate as translateTransform}from"../../transform.js";import{ascending}from"../../array.js";import{boundingExtent,buffer,containsExtent,equals,getIntersection,getTopLeft,intersects}from"../../extent.js";import{getSquaredTolerance as getSquaredRenderTolerance,renderFeature}from"../vector.js";import{getUid}from"../../util.js";import{toSize}from"../../size.js";import{wrapX}from"../../coordinate.js";const IMAGE_REPLAYS={image:["Polygon","Circle","LineString","Image","Text"],hybrid:["Polygon","LineString"],vector:[]},VECTOR_REPLAYS={hybrid:["Image","Text","Default"],vector:["Polygon","Circle","LineString","Image","Text","Default"]};class CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer{constructor(e){super(e),this.boundHandleStyleImageChange_=this.handleStyleImageChange_.bind(this),this.renderedLayerRevision_,this.renderedPixelToCoordinateTransform_=null,this.renderedRotation_,this.renderedOpacity_=1,this.tmpTransform_=createTransform(),this.tileClipContexts_=null}prepareTile(e,t,r){let o;var n=e.getState();return n!==TileState.LOADED&&n!==TileState.ERROR||(this.updateExecutorGroup_(e,t,r),this.tileImageNeedsRender_(e)&&(o=!0)),o}getTile(e,t,r,o){var n=o.pixelRatio,i=o.viewState,a=i.resolution,i=i.projection;const s=this.getLayer(),l=s.getSource().getTile(e,t,r,n,i);var d=o.viewHints,d=!(d[ViewHint.ANIMATING]||d[ViewHint.INTERACTING]),a=(!d&&l.wantedResolution||(l.wantedResolution=a),this.prepareTile(l,n,i));return a&&(d||Date.now()-o.time<8)&&"vector"!==s.getRenderMode()&&this.renderTileImage_(l,o),super.getTile(e,t,r,o)}isDrawableTile(e){const t=this.getLayer();return super.isDrawableTile(e)&&("vector"===t.getRenderMode()?getUid(t)in e.executorGroups:e.hasContext(t))}getTileImage(e){return e.getImage(this.getLayer())}prepareFrame(e){var t=this.getLayer().getRevision();return this.renderedLayerRevision_!==t&&(this.renderedLayerRevision_=t,this.renderedTiles.length=0),super.prepareFrame(e)}updateExecutorGroup_(r,o,e){const n=this.getLayer();var t=n.getRevision(),i=n.getRenderOrder()||null;const a=r.wantedResolution,s=r.getReplayState(n);if(s.dirty||s.renderedResolution!==a||s.renderedRevision!=t||s.renderedRenderOrder!=i){const f=n.getSource(),m=!!n.getDeclutter(),v=f.getTileGrid(),R=f.getTileGridForProjection(e);var l=R.getTileCoordExtent(r.wrappedTileCoord),d=f.getSourceTiles(o,e,r),c=getUid(n);delete r.hitDetectionImageData[c],r.executorGroups[c]=[],s.dirty=!1;for(let e=0,t=d.length;e<t;++e){const x=d[e];if(x.getState()==TileState.LOADED){var g=x.tileCoord,g=v.getTileCoordExtent(g),u=getIntersection(l,g),h=buffer(u,n.getRenderBuffer()*a,this.tmpExtent),T=equals(g,u)?null:h;const C=new CanvasBuilderGroup(0,u,a,o),y=getSquaredRenderTolerance(a,o);function p(e,t){let r;const o=e.getStyleFunction()||n.getStyleFunction();(r=o?o(e,a):r)&&(e=this.renderFeature(e,y,r,C,m,t),s.dirty=s.dirty||e)}const S=x.getFeatures();i&&i!==s.renderedRenderOrder&&S.sort(i);for(let e=0,t=S.length;e<t;++e){const E=S[e];T&&!intersects(T,E.getGeometry().getExtent())||p.call(this,E,e)}g=C.finish(),h="vector"!==n.getRenderMode()&&m&&1===d.length?null:u,u=new CanvasExecutorGroup(h,a,o,f.getOverlaps(),g,n.getRenderBuffer(),!0);r.executorGroups[c].push(u)}}s.renderedRevision=t,s.renderedRenderOrder=i,s.renderedResolution=a}}forEachFeatureAtCoordinate(i,a,s,l,d){const c=a.viewState.resolution,g=a.viewState.rotation,u=(s=null==s?0:s,this.getLayer()),e=u.getSource(),r=e.getTileGridForProjection(a.viewState.projection);var o=boundingExtent([i]);buffer(o,c*s,o);function h(e,t,r){let o=e.getId();void 0===o&&(o=getUid(e));const n=T[o];if(n){if(!0!==n&&r<n.distanceSq){if(0===r)return T[o]=!0,d.splice(d.lastIndexOf(n),1),l(e,u,t);n.geometry=t,n.distanceSq=r}}else{if(0===r)return T[o]=!0,l(e,u,t);d.push(T[o]={feature:e,layer:u,geometry:t,distanceSq:r,callback:l})}}const T={};var n=this.renderedTiles;let p;for(let e=0,t=n.length;!p&&e<t;++e){var f=n[e],m=r.getTileCoordExtent(f.wrappedTileCoord);if(intersects(m,o)){m=getUid(u);const v=[f.executorGroups[m]],R=u.getDeclutter();v.some(r=>{var o=R?a.declutter[R].all().map(e=>e.value):null;for(let e=0,t=r.length;e<t;++e){const n=r[e];if(p=n.forEachFeatureAtCoordinate(i,c,g,s,h,o))return!0}})}}return p}getFeatures(m){return new Promise((t,e)=>{const r=this.getLayer();var o=getUid(r);const n=r.getSource(),i=this.renderedProjection;var a=i.getExtent(),s=this.renderedResolution;const l=n.getTileGridForProjection(i);var d=applyTransform(this.renderedPixelToCoordinateTransform_,m.slice());const c=l.getTileCoordForCoordAndResolution(d,s);let g;for(let e=0,t=this.renderedTiles.length;e<t;++e)if(c.toString()===this.renderedTiles[e].tileCoord.toString()){if((g=this.renderedTiles[e]).getState()===TileState.LOADED){const f=l.getTileCoordExtent(g.tileCoord);n.getWrapX()&&i.canWrapX()&&!containsExtent(a,f)&&wrapX(d,i);break}g=void 0}if(!g||0<g.loadingSourceTiles)t([]);else{const f=l.getTileCoordExtent(g.wrappedTileCoord);var u,h,T=getTopLeft(f),T=[(d[0]-T[0])/s,(T[1]-d[1])/s],p=g.getSourceTiles().reduce(function(e,t){return e.concat(t.getFeatures())},[]);let e=g.hitDetectionImageData[o];e||(u=toSize(l.getTileSize(l.getZForResolution(s,n.zDirection))),h=this.renderedRotation_,s=[this.getRenderTransform(l.getTileCoordCenter(g.wrappedTileCoord),s,0,HIT_DETECT_RESOLUTION,u[0]*HIT_DETECT_RESOLUTION,u[1]*HIT_DETECT_RESOLUTION,0)],e=createHitDetectionImageData(u,s,p,r.getStyleFunction(),l.getTileCoordExtent(g.wrappedTileCoord),g.getReplayState(r).renderedResolution,h),g.hitDetectionImageData[o]=e),t(hitDetect(T,p,e))}})}handleFontsChanged(){const e=this.getLayer();e.getVisible()&&void 0!==this.renderedLayerRevision_&&e.changed()}handleStyleImageChange_(e){this.renderIfReadyAndVisible()}renderDeclutter(r,e){const t=this.context;var o=t.globalAlpha,e=(t.globalAlpha=e.opacity,r.viewHints),n=!(e[ViewHint.ANIMATING]||e[ViewHint.INTERACTING]),i=this.renderedTiles;for(let e=0,t=i.length;e<t;++e){var a=i[e];const l=a.executorGroups[getUid(this.getLayer())];var s=this.getLayer().getDeclutter();if(l)for(let e=l.length-1;0<=e;--e)l[e].execute(this.context,[this.context.canvas.width,this.context.canvas.height],this.getTileRenderTransform(a,r),r.viewState.rotation,n,DECLUTTER,s?r.declutter[s]:void 0)}t.globalAlpha=o}renderDeferredInternal(e){const t=this.renderedTiles,s=t.reduce((t,e,r)=>(e.executorGroups[getUid(this.getLayer())].forEach(e=>t.push({executorGroup:e,index:r})),t),[]),r=s.map(({executorGroup:e})=>e.getDeferredZIndexContexts()),o={};for(let e=0,t=s.length;e<t;++e)for(const i in s[e].executorGroup.getDeferredZIndexContexts())o[i]=!0;const n=Object.keys(o).sort(ascending);n.map(Number).forEach(t=>{r.forEach((e,a)=>{e[t]&&(e[t].forEach(e=>{const{executorGroup:t,index:r}=s[a],o=t.getRenderedContext();var n=o.globalAlpha;o.globalAlpha=this.renderedOpacity_;const i=this.tileClipContexts_[r];i&&i.draw(o),e.draw(o),i&&o.restore(),o.globalAlpha=n,e.clear()}),e[t].length=0)})})}getTileRenderTransform(e,t){var r=t.pixelRatio,o=t.viewState,n=o.center,i=o.resolution,o=o.rotation,a=t.size,s=Math.round(a[0]*r),a=Math.round(a[1]*r);const l=this.getLayer().getSource(),d=l.getTileGridForProjection(t.viewState.projection);t=e.tileCoord,e=d.getTileCoordExtent(e.wrappedTileCoord),t=d.getTileCoordExtent(t,this.tmpExtent)[0]-e[0];return multiply(scale(this.inversePixelTransform.slice(),1/r,1/r),this.getRenderTransform(n,i,o,r,s,a,t))}postRender(n,i){var e=i.viewHints,a=!(e[ViewHint.ANIMATING]||e[ViewHint.INTERACTING]);this.renderedPixelToCoordinateTransform_=i.pixelToCoordinateTransform.slice(),this.renderedRotation_=i.viewState.rotation,this.renderedOpacity_=i.layerStatesArray[i.layerIndex].opacity;const r=this.getLayer();var e=r.getRenderMode(),t=n.globalAlpha,s=(n.globalAlpha=this.renderedOpacity_,r.getDeclutter());const l=s?VECTOR_REPLAYS[e].filter(e=>!DECLUTTER.includes(e)):VECTOR_REPLAYS[e];var e=i.viewState,d=e.rotation;const o=r.getSource(),c=o.getTileGridForProjection(e.projection);var g=c.getZForResolution(e.resolution,o.zDirection),u=this.renderedTiles;const h=[],T=[],p=[];let f=!0;for(let t=u.length-1;0<=t;--t){const C=u[t],y=(f=f&&!C.getReplayState(r).dirty,C.executorGroups[getUid(r)].filter(e=>e.hasExecutors(l)));if(0!==y.length){var m=this.getTileRenderTransform(C,i),v=C.tileCoord[0];let r=!1;var R,x=y[0].getClipCoords(m);let o=n,e;if(x){e=new ZIndexContext,o=e.getContext();for(let e=0,t=h.length;e<t;++e)g!==v&&v<T[e]&&(R=h[e],intersects([x[0],x[3],x[4],x[7]],[R[0],R[3],R[4],R[7]])&&(r||(o.save(),r=!0),o.beginPath(),o.moveTo(x[0],x[1]),o.lineTo(x[2],x[3]),o.lineTo(x[4],x[5]),o.lineTo(x[6],x[7]),o.moveTo(R[6],R[7]),o.lineTo(R[4],R[5]),o.lineTo(R[2],R[3]),o.lineTo(R[0],R[1]),o.clip()));h.push(x),T.push(v)}for(let e=0,t=y.length;e<t;++e){const S=y[e];S.execute(n,[n.canvas.width,n.canvas.height],m,d,a,l,i.declutter?.[s])}r&&(o===n?o.restore():p[t]=e)}}n.globalAlpha=t,this.ready=f,this.tileClipContexts_=p,i.declutter||this.renderDeferredInternal(i),super.postRender(n,i)}renderFeature(r,o,n,i,a,s){if(!n)return!1;let l=!1;if(Array.isArray(n))for(let e=0,t=n.length;e<t;++e)l=renderFeature(i,r,n[e],o,this.boundHandleStyleImageChange_,void 0,a,s)||l;else l=renderFeature(i,r,n,o,this.boundHandleStyleImageChange_,void 0,a,s);return l}tileImageNeedsRender_(e){const t=this.getLayer();if("vector"===t.getRenderMode())return!1;var r=e.getReplayState(t),o=t.getRevision(),e=e.wantedResolution;return r.renderedTileResolution!==e||r.renderedTileRevision!==o}renderTileImage_(e,t){const r=this.getLayer(),o=e.getReplayState(r);var n=r.getRevision(),i=e.executorGroups[getUid(r)],n=(o.renderedTileRevision=n,e.wrappedTileCoord),a=n[0];const s=r.getSource();var l=t.pixelRatio,d=t.viewState.projection;const c=s.getTileGridForProjection(d);var g=c.getResolution(e.tileCoord[0]),t=t.pixelRatio/e.wantedResolution*g,g=c.getResolution(a);const u=e.getContext(r);var l=Math.round(Math.max(l,t/l)),a=s.getTilePixelSize(a,l,d),h=(u.canvas.width=a[0],u.canvas.height=a[1],l/t),a=(1!=h&&(d=resetTransform(this.tmpTransform_),scaleTransform(d,h,h),u.setTransform.apply(u,d)),c.getTileCoordExtent(n,this.tmpExtent)),l=t/g,T=resetTransform(this.tmpTransform_);scaleTransform(T,l,-l),translateTransform(T,-a[0],-a[3]);for(let e=0,t=i.length;e<t;++e){const p=i[e];p.execute(u,[u.canvas.width*h,u.canvas.height*h],T,0,!0,IMAGE_REPLAYS[r.getRenderMode()],null)}o.renderedTileResolution=e.wantedResolution}}export default CanvasVectorTileLayerRenderer;