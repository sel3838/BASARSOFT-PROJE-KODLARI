import CanvasLayerRenderer from"./Layer.js";import ImageTile from"../../ImageTile.js";import ReprojTile from"../../reproj/Tile.js";import TileRange from"../../TileRange.js";import TileState from"../../TileState.js";import{apply as applyTransform,compose as composeTransform}from"../../transform.js";import{ascending}from"../../array.js";import{containsCoordinate,createEmpty,equals,getIntersection,getRotatedViewport,getTopLeft,intersects}from"../../extent.js";import{fromUserExtent}from"../../proj.js";import{getUid}from"../../util.js";import{toSize}from"../../size.js";class CanvasTileLayerRenderer extends CanvasLayerRenderer{constructor(e){super(e),this.extentChanged=!0,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedRevision,this.renderedTiles=[],this.newTiles_=!1,this.tmpExtent=createEmpty(),this.tmpTileRange_=new TileRange(0,0,0,0)}isDrawableTile(e){const t=this.getLayer();var e=e.getState(),i=t.getUseInterimTilesOnError();return e==TileState.LOADED||e==TileState.EMPTY||e==TileState.ERROR&&!i}getTile(e,t,i,r){var o=r.pixelRatio,r=r.viewState.projection;const n=this.getLayer(),a=n.getSource();let s=a.getTile(e,t,i,o,r);return s.getState()==TileState.ERROR&&n.getUseInterimTilesOnError()&&0<n.getPreload()&&(this.newTiles_=!0),s=this.isDrawableTile(s)?s:s.getInterimTile()}getData(e){var t=this.frameState;if(!t)return null;const i=this.getLayer();var r=applyTransform(t.pixelToCoordinateTransform,e.slice()),e=i.getExtent();if(e&&!containsCoordinate(e,r))return null;var o=t.pixelRatio,n=t.viewState.projection,a=t.viewState;const s=i.getRenderSource(),l=s.getTileGridForProjection(a.projection);var d=s.getTilePixelRatio(t.pixelRatio);for(let e=l.getZForResolution(a.resolution);e>=l.getMinZoom();--e){var g,T,h,c,m=l.getTileCoordForCoordAndZ(r,e);const p=s.getTile(e,m[1],m[2],o,n);if(!(p instanceof ImageTile||p instanceof ReprojTile)||p instanceof ReprojTile&&p.getState()===TileState.EMPTY)return null;if(p.getState()!==TileState.LOADED);else return h=l.getOrigin(e),g=toSize(l.getTileSize(e)),c=l.getResolution(e),T=Math.floor(d*((r[0]-h[0])/c-m[1]*g[0])),h=Math.floor(d*((h[1]-r[1])/c-m[2]*g[1])),c=Math.round(d*s.getGutterForProjection(a.projection)),this.getImageData(p.getImage(),T+c,h+c)}return null}loadedTileCallback(e,t,i){return!!this.isDrawableTile(i)&&super.loadedTileCallback(e,t,i)}prepareFrame(e){return!!this.getLayer().getSource()}renderFrame(r,e){var o=r.layerStatesArray[r.layerIndex],t=r.viewState,i=t.projection,_=t.resolution,n=t.center,O=t.rotation,a=r.pixelRatio;const z=this.getLayer(),s=z.getSource();var Z=s.getRevision();const l=s.getTileGridForProjection(i);var d=l.getZForResolution(_,s.zDirection),g=l.getResolution(d);let T=r.extent;var Y=r.viewState.resolution,h=s.getTilePixelRatio(a),e=(this.prepareContainer(r,e),this.context.canvas.width),V=this.context.canvas.height,q=o.extent&&fromUserExtent(o.extent,i);q&&(T=getIntersection(T,fromUserExtent(o.extent,i)));const c=g*e/2/h,m=g*V/2/h;var p=[n[0]-c,n[1]-m,n[0]+c,n[1]+m],u=l.getTileRangeForExtentAndZ(T,d);const f={},G=(f[d]={},this.createLoadedTileFinder(s,i,f));var K=this.tmpExtent,X=this.tmpTileRange_,k=(this.newTiles_=!1,O?getRotatedViewport(t.center,Y,O,r.size):void 0);for(let i=u.minX;i<=u.maxX;++i)for(let t=u.minY;t<=u.maxY;++t)if(!O||l.tileCoordIntersectsViewport([d,i,t],k)){const F=this.getTile(d,i,t,r);if(this.isDrawableTile(F)){var v=getUid(this);if(F.getState()==TileState.LOADED){let e=(f[d][F.tileCoord.toString()]=F).inTransition(v);e&&1!==o.opacity&&(F.endTransition(v),e=!1),this.newTiles_||!e&&this.renderedTiles.includes(F)||(this.newTiles_=!0)}if(1===F.getAlpha(v,r.time))continue}v=l.getTileCoordChildTileRange(F.tileCoord,X,K);let e=!1;(e=v?G(d+1,v):e)||l.forEachTileCoordParentTileRange(F.tileCoord,G,X,K)}var R=g/_*a/h;const x=this.getRenderContext(r);composeTransform(this.tempTransform,e/2,V/2,R,R,0,-e/2,-V/2),q&&this.clipUnrotated(x,r,q),s.getInterpolate()||(x.imageSmoothingEnabled=!1),this.preRender(x,r),this.renderedTiles.length=0;let S=Object.keys(f).map(Number);S.sort(ascending);let C,Q,y;1!==o.opacity||this.containerReused&&!s.getOpaque(r.viewState.projection)?(C=[],Q=[]):S=S.reverse();for(let e=S.length-1;0<=e;--e){var w=S[e],E=s.getTilePixelSize(w,a,i),N=l.getResolution(w)/g;const c=E[0]*N*R,m=E[1]*N*R;var B=l.getTileCoordForCoordAndZ(getTopLeft(p),w),E=l.getTileCoordExtent(B),j=applyTransform(this.tempTransform,[h*(E[0]-p[0])/g,h*(p[3]-E[3])/g]),H=h*s.getGutterForProjection(i),J=f[w];for(const ee in J){const M=J[ee];var I,P=M.tileCoord,L=B[1]-P[1],W=Math.round(j[0]-(L-1)*c),P=B[2]-P[2],$=Math.round(j[1]-(P-1)*m),U=Math.round(j[0]-L*c),b=Math.round(j[1]-P*m),A=W-U,D=$-b,L=d===w,P=L&&1!==M.getAlpha(getUid(this),r.time);let i=!1;if(!P)if(C){y=[U,b,U+A,b,U+A,b+D,U,b+D];for(let e=0,t=C.length;e<t;++e)d!==w&&w<Q[e]&&(I=C[e],intersects([U,b,U+A,b+D],[I[0],I[3],I[4],I[7]])&&(i||(x.save(),i=!0),x.beginPath(),x.moveTo(y[0],y[1]),x.lineTo(y[2],y[3]),x.lineTo(y[4],y[5]),x.lineTo(y[6],y[7]),x.moveTo(I[6],I[7]),x.lineTo(I[4],I[5]),x.lineTo(I[2],I[3]),x.lineTo(I[0],I[1]),x.clip()));C.push(y),Q.push(w)}else x.clearRect(U,b,A,D);this.drawTileImage(M,r,U,b,A,D,H,L),C&&!P?(i&&x.restore(),this.renderedTiles.unshift(M)):this.renderedTiles.push(M),this.updateUsedTiles(r.usedTiles,s,M)}}return this.renderedRevision=Z,this.renderedResolution=g,this.extentChanged=!this.renderedExtent_||!equals(this.renderedExtent_,p),this.renderedExtent_=p,this.renderedPixelRatio=a,this.renderedProjection=i,this.manageTilePyramid(r,s,l,a,i,T,d,z.getPreload()),this.scheduleExpireCache(r,s),this.postRender(this.context,r),o.extent&&x.restore(),x.imageSmoothingEnabled=!0,this.container}drawTileImage(e,t,i,r,o,n,a,s){var l=this.getTileImage(e);if(l){const c=this.getRenderContext(t);var d=getUid(this),g=t.layerStatesArray[t.layerIndex],T=g.opacity*(s?e.getAlpha(d,t.time):1),h=T!==c.globalAlpha;h&&(c.save(),c.globalAlpha=T),c.drawImage(l,a,a,l.width-2*a,l.height-2*a,i,r,o,n),h&&c.restore(),T!==g.opacity?t.animate=!0:s&&e.endTransition(d)}}getImage(){var e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}scheduleExpireCache(e,t){t.canExpireCache()&&(t=function(e,t,i){var r=getUid(e);r in i.usedTiles&&e.expireCache(i.viewState.projection,i.usedTiles[r])}.bind(null,t),e.postRenderFunctions.push(t))}updateUsedTiles(e,t,i){t=getUid(t);t in e||(e[t]={}),e[t][i.getKey()]=!0}manageTilePyramid(e,t,i,r,o,n,a,s,l){var d=getUid(t);d in e.wantedTiles||(e.wantedTiles[d]={});const g=e.wantedTiles[d],T=e.tileQueue;var h=i.getMinZoom(),c=e.viewState.rotation,m=c?getRotatedViewport(e.viewState.center,e.viewState.resolution,c,e.size):void 0;let p=0,u,f,v,R,x,S;for(S=h;S<=a;++S)for(f=i.getTileRangeForExtentAndZ(n,S,f),v=i.getResolution(S),R=f.minX;R<=f.maxX;++R)for(x=f.minY;x<=f.maxY;++x)c&&!i.tileCoordIntersectsViewport([S,R,x],m)||(a-S<=s?(++p,(u=t.getTile(S,R,x,r,o)).getState()==TileState.IDLE&&(g[u.getKey()]=!0,T.isKeyQueued(u.getKey())||T.enqueue([u,d,i.getTileCoordCenter(u.tileCoord),v])),void 0!==l&&l(u)):t.useTile(S,R,x,o));t.updateCacheSize(p,o)}}export default CanvasTileLayerRenderer;