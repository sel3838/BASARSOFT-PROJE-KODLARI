import EventType from"../../events/EventType.js";import TileGeometry from"../../webgl/TileGeometry.js";import VectorStyleRenderer from"../../render/webgl/VectorStyleRenderer.js";import WebGLArrayBuffer from"../../webgl/Buffer.js";import WebGLBaseTileLayerRenderer,{Uniforms as BaseUniforms}from"./TileLayerBase.js";import WebGLRenderTarget from"../../webgl/RenderTarget.js";import{AttributeType}from"../../webgl/Helper.js";import{ELEMENT_ARRAY_BUFFER,STATIC_DRAW}from"../../webgl.js";import{ShaderBuilder}from"../../webgl/ShaderBuilder.js";import{create as createMat4,fromTransform as mat4FromTransform}from"../../vec/mat4.js";import{create as createTransform,makeInverse as makeInverseTransform,multiply as multiplyTransform,setFromArray as setFromTransform}from"../../transform.js";import{getIntersection}from"../../extent.js";import{parseLiteralStyle}from"../../webgl/styleparser.js";const Uniforms={...BaseUniforms,TILE_MASK_TEXTURE:"u_depthMask",TILE_ZOOM_LEVEL:"u_tileZoomLevel"},Attributes={POSITION:"a_position"};class WebGLVectorTileLayerRenderer extends WebGLBaseTileLayerRenderer{constructor(e,r){super(e,{cacheSize:r.cacheSize,uniforms:{[Uniforms.PATTERN_ORIGIN]:[0,0],[Uniforms.TILE_MASK_TEXTURE]:()=>this.tileMaskTarget_.getTexture()}}),this.hitDetectionEnabled_=!r.disableHitDetection,this.styles_=[],this.styleRenderers_=[],this.currentFrameStateTransform_=createTransform(),this.tmpTransform_=createTransform(),this.tmpMat4_=createMat4(),this.tileMaskTarget_=null,this.tileMaskIndices_=new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER,STATIC_DRAW),this.tileMaskIndices_.fromArray([0,1,3,1,2,3]),this.tileMaskAttributes_=[{name:Attributes.POSITION,size:2,type:AttributeType.FLOAT}],this.tileMaskProgram_,this.applyOptions_(r)}reset(e){super.reset(e),this.applyOptions_(e),this.helper&&(this.createRenderers_(),this.initTileMask_())}applyOptions_(e){this.styles_=Array.isArray(e.style)?e.style:[e.style]}createRenderers_(){function s(e){var r=e.getFragmentDiscardExpression(),t=`texture2D(${Uniforms.TILE_MASK_TEXTURE}, gl_FragCoord.xy / u_pixelRatio / u_viewportSizePx).r * 50. > ${Uniforms.TILE_ZOOM_LEVEL} + 0.5`;e.setFragmentDiscardExpression("false"!==r?`(${r}) || (${t})`:t),e.addUniform("sampler2D "+Uniforms.TILE_MASK_TEXTURE),e.addUniform("float "+Uniforms.TILE_ZOOM_LEVEL)}this.styleRenderers_=this.styles_.map(e=>{var r="builder"in e;let t;return t=r?(s(e.builder),e):(s((r=parseLiteralStyle(e)).builder),{builder:r.builder,attributes:r.attributes,uniforms:r.uniforms}),new VectorStyleRenderer(t,this.helper,this.hitDetectionEnabled_)})}initTileMask_(){this.tileMaskTarget_=new WebGLRenderTarget(this.helper);const e=(new ShaderBuilder).setFillColorExpression(`vec4(${Uniforms.TILE_ZOOM_LEVEL} / 50., 0., 0., 1.)`).addUniform("float "+Uniforms.TILE_ZOOM_LEVEL);this.tileMaskProgram_=this.helper.getProgram(e.getFillFragmentShader(),e.getFillVertexShader()),this.helper.flushBufferData(this.tileMaskIndices_)}afterHelperCreated(){this.createRenderers_(),this.initTileMask_()}createTileRepresentation(e){const r=new TileGeometry(e,this.styleRenderers_),t=()=>{r.ready&&(this.getLayer().changed(),r.removeEventListener(EventType.CHANGE,t))};return r.addEventListener(EventType.CHANGE,t),r}beforeTilesRender(e,r){super.beforeTilesRender(e,!0),this.helper.makeProjectionTransform(e,this.currentFrameStateTransform_)}beforeTilesMaskRender(e){this.helper.makeProjectionTransform(e,this.currentFrameStateTransform_);var r=e.pixelRatio,t=e.size;return this.tileMaskTarget_.setSize([t[0]*r,t[1]*r]),this.helper.prepareDrawToRenderTarget(e,this.tileMaskTarget_,!0,!0),this.helper.useProgram(this.tileMaskProgram_,e),setFromTransform(this.tmpTransform_,this.currentFrameStateTransform_),this.helper.setUniformMatrixValue(Uniforms.PROJECTION_MATRIX,mat4FromTransform(this.tmpMat4_,this.tmpTransform_)),makeInverseTransform(this.tmpTransform_,this.currentFrameStateTransform_),this.helper.setUniformMatrixValue(Uniforms.SCREEN_TO_WORLD_MATRIX,mat4FromTransform(this.tmpMat4_,this.tmpTransform_)),!0}renderTileMask(e,r,t,s){e.ready&&(this.helper.setUniformFloatValue(Uniforms.DEPTH,s),this.helper.setUniformFloatValue(Uniforms.TILE_ZOOM_LEVEL,r),this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT,t),this.helper.setUniformFloatValue(Uniforms.GLOBAL_ALPHA,1),this.helper.bindBuffer(e.maskVertices),this.helper.bindBuffer(this.tileMaskIndices_),this.helper.enableAttributes(this.tileMaskAttributes_),s=this.tileMaskIndices_.getSize(),this.helper.drawElements(0,s))}applyUniforms_(e,r,t,s,i){setFromTransform(this.tmpTransform_,this.currentFrameStateTransform_),multiplyTransform(this.tmpTransform_,t),this.helper.setUniformMatrixValue(Uniforms.PROJECTION_MATRIX,mat4FromTransform(this.tmpMat4_,this.tmpTransform_)),makeInverseTransform(this.tmpTransform_,this.currentFrameStateTransform_),this.helper.setUniformMatrixValue(Uniforms.SCREEN_TO_WORLD_MATRIX,mat4FromTransform(this.tmpMat4_,this.tmpTransform_)),this.helper.setUniformFloatValue(Uniforms.GLOBAL_ALPHA,e),this.helper.setUniformFloatValue(Uniforms.DEPTH,i),this.helper.setUniformFloatValue(Uniforms.TILE_ZOOM_LEVEL,s),this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT,r)}renderTile(t,e,s,r,i,a,n,o,m,l,f){const h=getIntersection(o,r,o),T=t.tile.getTileCoord()[0];for(let e=0,r=this.styleRenderers_.length;e<r;e++){const _=this.styleRenderers_[e],p=t.buffers[e];_.render(p,s,()=>{this.applyUniforms_(f,h,p.invertVerticesTransform,T,m)})}}renderDeclutter(e){}disposeInternal(){super.disposeInternal()}}export default WebGLVectorTileLayerRenderer;export{Uniforms,Attributes};