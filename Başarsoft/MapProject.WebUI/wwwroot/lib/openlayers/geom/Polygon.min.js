import LinearRing from"./LinearRing.js";import Point from"./Point.js";import SimpleGeometry from"./SimpleGeometry.js";import{arrayMaxSquaredDelta,assignClosestArrayPoint}from"./flat/closest.js";import{closestSquaredDistanceXY,getCenter,isEmpty}from"../extent.js";import{deflateCoordinatesArray}from"./flat/deflate.js";import{extend}from"../array.js";import{getInteriorPointOfArray}from"./flat/interiorpoint.js";import{inflateCoordinatesArray}from"./flat/inflate.js";import{intersectsLinearRingArray}from"./flat/intersectsextent.js";import{linearRingsAreOriented,orientLinearRings}from"./flat/orient.js";import{linearRings as linearRingsArea}from"./flat/area.js";import{linearRingsContainsXY}from"./flat/contains.js";import{modulo}from"../math.js";import{quantizeArray}from"./flat/simplify.js";import{offset as sphereOffset}from"../sphere.js";class Polygon extends SimpleGeometry{constructor(t,e,i){super(),this.ends_=[],this.flatInteriorPointRevision_=-1,this.flatInteriorPoint_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,void 0!==e&&i?(this.setFlatCoordinates(e,t),this.ends_=i):this.setCoordinates(t,e)}appendLinearRing(t){this.flatCoordinates?extend(this.flatCoordinates,t.getFlatCoordinates()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){const t=new Polygon(this.flatCoordinates.slice(),this.layout,this.ends_.slice());return t.applyProperties(this),t}closestPointXY(t,e,i,n){return n<closestSquaredDistanceXY(this.getExtent(),t,e)?n:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),assignClosestArrayPoint(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!0,t,e,i,n))}containsXY(t,e){return linearRingsContainsXY(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,e)}getArea(){return linearRingsArea(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride)}getCoordinates(t){let e;return void 0!==t?(e=this.getOrientedFlatCoordinates().slice(),orientLinearRings(e,0,this.ends_,this.stride,t)):e=this.flatCoordinates,inflateCoordinatesArray(e,0,this.ends_,this.stride)}getEnds(){return this.ends_}getFlatInteriorPoint(){var t;return this.flatInteriorPointRevision_!=this.getRevision()&&(t=getCenter(this.getExtent()),this.flatInteriorPoint_=getInteriorPointOfArray(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,0),this.flatInteriorPointRevision_=this.getRevision()),this.flatInteriorPoint_}getInteriorPoint(){return new Point(this.getFlatInteriorPoint(),"XYM")}getLinearRingCount(){return this.ends_.length}getLinearRing(t){return t<0||this.ends_.length<=t?null:new LinearRing(this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t]),this.layout)}getLinearRings(){var i=this.layout;const n=this.flatCoordinates;var r=this.ends_;const s=[];let o=0;for(let t=0,e=r.length;t<e;++t){var a=r[t],l=new LinearRing(n.slice(o,a),i);s.push(l),o=a}return s}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;linearRingsAreOriented(t,0,this.ends_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=orientLinearRings(this.orientedFlatCoordinates_,0,this.ends_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(t){const e=[];var i=[];return e.length=quantizeArray(this.flatCoordinates,0,this.ends_,this.stride,Math.sqrt(t),e,0,i),new Polygon(e,"XY",i)}getType(){return"Polygon"}intersectsExtent(t){return intersectsLinearRingArray(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);e=deflateCoordinatesArray(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===e.length?0:e[e.length-1],this.changed()}}export default Polygon;function circular(e,i,n,r){n=n||32;const s=[];for(let t=0;t<n;++t)extend(s,sphereOffset(e,i,2*Math.PI*t/n,r));return s.push(s[0],s[1]),new Polygon(s,"XY",[s.length])}function fromExtent(t){if(isEmpty(t))throw new Error("Cannot create polygon from empty extent");var e=t[0],i=t[1],n=t[2],t=t[3],t=[e,i,e,t,n,t,n,i,e,i];return new Polygon(t,"XY",[t.length])}function fromCircle(t,e,i){e=e||32;var n=t.getStride(),r=t.getLayout(),s=t.getCenter(),o=n*(e+1);const a=new Array(o);for(let e=0;e<o;e+=n){a[e]=0,a[e+1]=0;for(let t=2;t<n;t++)a[e+t]=s[t]}e=[a.length],r=new Polygon(a,r,e);return makeRegular(r,s,t.getRadius(),i),r}function makeRegular(t,e,i,n){const r=t.getFlatCoordinates();var s=t.getStride(),o=r.length/s-1,a=n||0;for(let t=0;t<=o;++t){var l=t*s;const n=a+2*modulo(t,o)*Math.PI/o;r[l]=e[0]+i*Math.cos(n),r[1+l]=e[1]+i*Math.sin(n)}t.changed()}export{circular,fromExtent,fromCircle,makeRegular};