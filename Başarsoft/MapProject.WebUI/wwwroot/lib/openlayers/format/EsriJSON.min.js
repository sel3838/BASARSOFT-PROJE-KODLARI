import Feature from"../Feature.js";import JSONFeature from"./JSONFeature.js";import LineString from"../geom/LineString.js";import LinearRing from"../geom/LinearRing.js";import MultiLineString from"../geom/MultiLineString.js";import MultiPoint from"../geom/MultiPoint.js";import MultiPolygon from"../geom/MultiPolygon.js";import Point from"../geom/Point.js";import Polygon from"../geom/Polygon.js";import{containsExtent}from"../extent.js";import{deflateCoordinates}from"../geom/flat/deflate.js";import{get as getProjection}from"../proj.js";import{isEmpty}from"../obj.js";import{linearRingIsClockwise}from"../geom/flat/orient.js";import{transformGeometryWithOptions}from"./Feature.js";const GEOMETRY_READERS={Point:readPointGeometry,LineString:readLineStringGeometry,Polygon:readPolygonGeometry,MultiPoint:readMultiPointGeometry,MultiLineString:readMultiLineStringGeometry,MultiPolygon:readMultiPolygonGeometry},GEOMETRY_WRITERS={Point:writePointGeometry,LineString:writeLineStringGeometry,Polygon:writePolygonGeometry,MultiPoint:writeMultiPointGeometry,MultiLineString:writeMultiLineStringGeometry,MultiPolygon:writeMultiPolygonGeometry};class EsriJSON extends JSONFeature{constructor(e){e=e||{},super(),this.geometryName_=e.geometryName}readFeatureFromObject(e,t,r){var t=readGeometry(e.geometry,t);const o=new Feature;return this.geometryName_&&o.setGeometryName(this.geometryName_),o.setGeometry(t),e.attributes&&(o.setProperties(e.attributes,!0),void 0!==(t=e.attributes[r])&&o.setId(t)),o}readFeaturesFromObject(r,o){if(o=o||{},r.features){const i=[];var n=r.features;for(let e=0,t=n.length;e<t;++e)i.push(this.readFeatureFromObject(n[e],o,r.objectIdFieldName));return i}return[this.readFeatureFromObject(r,o)]}readGeometryFromObject(e,t){return readGeometry(e,t)}readProjectionFromObject(e){return e.spatialReference&&void 0!==e.spatialReference.wkid?(e=e.spatialReference.wkid,getProjection("EPSG:"+e)):null}writeGeometryObject(e,t){return writeGeometry(e,this.adaptOptions(t))}writeFeatureObject(e,t){t=this.adaptOptions(t);const r={};if(!e.hasProperties())return r.attributes={},r;const o=e.getProperties();var n=e.getGeometry();return n&&(r.geometry=writeGeometry(n,t),(n=t&&(t.dataProjection||t.featureProjection))&&(r.geometry.spatialReference={wkid:Number(getProjection(n).getCode().split(":").pop())}),delete o[e.getGeometryName()]),isEmpty(o)?r.attributes={}:r.attributes=o,r}writeFeaturesObject(r,o){o=this.adaptOptions(o);const n=[];for(let e=0,t=r.length;e<t;++e)n.push(this.writeFeatureObject(r[e],o));return{features:n}}}function readGeometry(e,t){if(!e)return null;let r;var o,n;"number"==typeof e.x&&"number"==typeof e.y?r="Point":e.points?r="MultiPoint":e.paths?r=1===e.paths.length?"LineString":"MultiLineString":e.rings&&(o=getGeometryLayout(n=e),e=1===(n=convertRings(n.rings,o)).length?(r="Polygon",Object.assign({},e,{rings:n[0]})):(r="MultiPolygon",Object.assign({},e,{rings:n})));const i=GEOMETRY_READERS[r];return transformGeometryWithOptions(i(e),!1,t)}function convertRings(e,t){const r=[],o=[],n=[];let i,a;for(i=0,a=e.length;i<a;++i)r.length=0,deflateCoordinates(r,0,e[i],t.length),linearRingIsClockwise(r,0,r.length,t.length)?o.push([e[i]]):n.push(e[i]);for(;n.length;){const u=n.shift();let e=!1;for(i=o.length-1;0<=i;i--){var s=o[i][0];if(containsExtent(new LinearRing(s).getExtent(),new LinearRing(u).getExtent())){o[i].push(u),e=!0;break}}e||o.push([u.reverse()])}return o}function readPointGeometry(e){let t;return t=void 0!==e.m&&void 0!==e.z?new Point([e.x,e.y,e.z,e.m],"XYZM"):void 0!==e.z?new Point([e.x,e.y,e.z],"XYZ"):void 0!==e.m?new Point([e.x,e.y,e.m],"XYM"):new Point([e.x,e.y])}function readLineStringGeometry(e){var t=getGeometryLayout(e);return new LineString(e.paths[0],t)}function readMultiLineStringGeometry(e){var t=getGeometryLayout(e);return new MultiLineString(e.paths,t)}function getGeometryLayout(e){let t="XY";return!0===e.hasZ&&!0===e.hasM?t="XYZM":!0===e.hasZ?t="XYZ":!0===e.hasM&&(t="XYM"),t}function readMultiPointGeometry(e){var t=getGeometryLayout(e);return new MultiPoint(e.points,t)}function readMultiPolygonGeometry(e){var t=getGeometryLayout(e);return new MultiPolygon(e.rings,t)}function readPolygonGeometry(e){var t=getGeometryLayout(e);return new Polygon(e.rings,t)}function writePointGeometry(e,t){var r=e.getCoordinates();let o;e=e.getLayout();if("XYZ"===e)o={x:r[0],y:r[1],z:r[2]};else if("XYM"===e)o={x:r[0],y:r[1],m:r[2]};else if("XYZM"===e)o={x:r[0],y:r[1],z:r[2],m:r[3]};else{if("XY"!==e)throw new Error("Invalid geometry layout");o={x:r[0],y:r[1]}}return o}function getHasZM(e){e=e.getLayout();return{hasZ:"XYZ"===e||"XYZM"===e,hasM:"XYM"===e||"XYZM"===e}}function writeLineStringGeometry(e,t){var r=getHasZM(e);return{hasZ:r.hasZ,hasM:r.hasM,paths:[e.getCoordinates()]}}function writePolygonGeometry(e,t){var r=getHasZM(e);return{hasZ:r.hasZ,hasM:r.hasM,rings:e.getCoordinates(!1)}}function writeMultiLineStringGeometry(e,t){var r=getHasZM(e);return{hasZ:r.hasZ,hasM:r.hasM,paths:e.getCoordinates()}}function writeMultiPointGeometry(e,t){var r=getHasZM(e);return{hasZ:r.hasZ,hasM:r.hasM,points:e.getCoordinates()}}function writeMultiPolygonGeometry(e,t){var r=getHasZM(e),o=e.getCoordinates(!1);const n=[];for(let t=0;t<o.length;t++)for(let e=o[t].length-1;0<=e;e--)n.push(o[t][e]);return{hasZ:r.hasZ,hasM:r.hasM,rings:n}}function writeGeometry(e,t){const r=GEOMETRY_WRITERS[e.getType()];return r(transformGeometryWithOptions(e,!0,t),t)}export default EsriJSON;