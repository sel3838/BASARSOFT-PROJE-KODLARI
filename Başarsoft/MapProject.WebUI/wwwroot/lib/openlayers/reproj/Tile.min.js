import{ERROR_THRESHOLD}from"./common.js";import EventType from"../events/EventType.js";import Tile from"../Tile.js";import TileState from"../TileState.js";import Triangulation from"./Triangulation.js";import{calculateSourceExtentResolution,canvasPool,render as renderReprojected}from"../reproj.js";import{clamp}from"../math.js";import{getArea,getIntersection,getWidth,wrapAndSliceX}from"../extent.js";import{listen,unlistenByKey}from"../events.js";import{releaseCanvas}from"../dom.js";class ReprojTile extends Tile{constructor(t,l,e,i,s,r,n,o,h,a,c,u){super(s,TileState.IDLE,u),this.renderEdges_=void 0!==c&&c,this.pixelRatio_=n,this.gutter_=o,this.canvas_=null,this.sourceTileGrid_=l,this.targetTileGrid_=i,this.wrappedTileCoord_=r||s,this.sourceTiles_=[],this.sourcesListenerKeys_=null,this.sourceZ_=0,this.clipExtent_=t.canWrapX()?t.getExtent():void 0;u=i.getTileCoordExtent(this.wrappedTileCoord_),c=this.targetTileGrid_.getExtent();let T=this.sourceTileGrid_.getExtent();o=c?getIntersection(u,c):u;if(0===getArea(o))this.state=TileState.EMPTY;else{r=t.getExtent(),s=(r&&(T=T?getIntersection(T,r):r),i.getResolution(this.wrappedTileCoord_[0])),c=calculateSourceExtentResolution(t,e,o,s);if(!isFinite(c)||c<=0)this.state=TileState.EMPTY;else if(this.triangulation_=new Triangulation(t,e,o,T,c*(void 0!==a?a:ERROR_THRESHOLD),s),0===this.triangulation_.getTriangles().length)this.state=TileState.EMPTY;else{this.sourceZ_=l.getZForResolution(c);let e=this.triangulation_.calculateSourceExtent();if(T&&(t.canWrapX()?(e[1]=clamp(e[1],T[1],T[3]),e[3]=clamp(e[3],T[1],T[3])):e=getIntersection(e,T)),getArea(e)){let o=0,a=0;t.canWrapX()&&(o=getWidth(r),a=Math.floor((e[0]-r[0])/o));const g=wrapAndSliceX(e.slice(),t,!0);g.forEach(e=>{var i=l.getTileRangeForExtentAndZ(e,this.sourceZ_);for(let t=i.minX;t<=i.maxX;t++)for(let e=i.minY;e<=i.maxY;e++){var s,r=h(this.sourceZ_,t,e,n);r&&(s=a*o,this.sourceTiles_.push({tile:r,offset:s}))}++a}),0===this.sourceTiles_.length&&(this.state=TileState.EMPTY)}else this.state=TileState.EMPTY}}}getImage(){return this.canvas_}reproject_(){const r=[];var e,t,i,s,o;this.sourceTiles_.forEach(e=>{const t=e.tile;if(t&&t.getState()==TileState.LOADED){const i=this.sourceTileGrid_.getTileCoordExtent(t.tileCoord),s=(i[0]+=e.offset,i[2]+=e.offset,this.clipExtent_?.slice());s&&(s[0]+=e.offset,s[2]+=e.offset),r.push({extent:i,clipExtent:s,image:t.getImage()})}}),(this.sourceTiles_.length=0)===r.length?this.state=TileState.ERROR:(i=this.wrappedTileCoord_[0],e="number"==typeof(t=this.targetTileGrid_.getTileSize(i))?t:t[0],t="number"==typeof t?t:t[1],i=this.targetTileGrid_.getResolution(i),s=this.sourceTileGrid_.getResolution(this.sourceZ_),o=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_),this.canvas_=renderReprojected(e,t,this.pixelRatio_,s,this.sourceTileGrid_.getExtent(),i,o,this.triangulation_,r,this.gutter_,this.renderEdges_,this.interpolate),this.state=TileState.LOADED),this.changed()}load(){if(this.state==TileState.IDLE){this.state=TileState.LOADING,this.changed();let r=0;this.sourcesListenerKeys_=[],this.sourceTiles_.forEach(({tile:i})=>{var e=i.getState();if(e==TileState.IDLE||e==TileState.LOADING){r++;const s=listen(i,EventType.CHANGE,function(e){var t=i.getState();t!=TileState.LOADED&&t!=TileState.ERROR&&t!=TileState.EMPTY||(unlistenByKey(s),0===--r&&(this.unlistenSources_(),this.reproject_()))},this);this.sourcesListenerKeys_.push(s)}}),0===r?setTimeout(this.reproject_.bind(this),0):this.sourceTiles_.forEach(function({tile:e},t,i){e.getState()==TileState.IDLE&&e.load()})}}unlistenSources_(){this.sourcesListenerKeys_.forEach(unlistenByKey),this.sourcesListenerKeys_=null}release(){this.canvas_&&(releaseCanvas(this.canvas_.getContext("2d")),canvasPool.push(this.canvas_),this.canvas_=null),super.release()}}export default ReprojTile;