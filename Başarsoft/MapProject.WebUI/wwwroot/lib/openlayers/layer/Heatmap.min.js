import BaseVector from"./BaseVector.js";import WebGLPointsLayerRenderer from"../renderer/webgl/PointsLayer.js";import{ShaderBuilder}from"../webgl/ShaderBuilder.js";import{clamp}from"../math.js";import{createCanvasContext2D}from"../dom.js";const Property={BLUR:"blur",GRADIENT:"gradient",RADIUS:"radius"},DEFAULT_GRADIENT=["#00f","#0ff","#0f0","#ff0","#f00"];class Heatmap extends BaseVector{constructor(e){e=e||{};const t=Object.assign({},e),r=(delete t.gradient,delete t.radius,delete t.blur,delete t.weight,super(t),this.gradient_=null,this.addChangeListener(Property.GRADIENT,this.handleGradientChanged_),this.setGradient(e.gradient||DEFAULT_GRADIENT),this.setBlur(void 0!==e.blur?e.blur:15),this.setRadius(void 0!==e.radius?e.radius:8),e.weight||"weight");"string"==typeof r?this.weightFunction_=function(e){return e.get(r)}:this.weightFunction_=r,this.setRenderOrder(null)}getBlur(){return this.get(Property.BLUR)}getGradient(){return this.get(Property.GRADIENT)}getRadius(){return this.get(Property.RADIUS)}handleGradientChanged_(){this.gradient_=createGradient(this.getGradient())}setBlur(e){this.set(Property.BLUR,e)}setGradient(e){this.set(Property.GRADIENT,e)}setRadius(e){this.set(Property.RADIUS,e)}createRenderer(){const e=(new ShaderBuilder).addAttribute("float a_prop_weight").addVarying("v_prop_weight","float","a_prop_weight").addUniform("float u_size").addUniform("float u_blurSlope").setSymbolSizeExpression("vec2(u_size)").setSymbolColorExpression("vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * u_blurSlope) * v_prop_weight)");return new WebGLPointsLayerRenderer(this,{className:this.getClassName(),attributes:[{name:"weight",callback:e=>{e=this.weightFunction_(e);return void 0!==e?clamp(e,0,1):1}}],uniforms:{u_size:()=>2*(this.get(Property.RADIUS)+this.get(Property.BLUR)),u_blurSlope:()=>this.get(Property.RADIUS)/Math.max(1,this.get(Property.BLUR))},hitDetectionEnabled:!0,vertexShader:e.getSymbolVertexShader(),fragmentShader:e.getSymbolFragmentShader(),postProcesses:[{fragmentShader:`
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`,uniforms:{u_gradientTexture:()=>this.gradient_,u_opacity:()=>this.getOpacity()}}]})}renderDeclutter(){}}function createGradient(r){const e=createCanvasContext2D(1,256),i=e.createLinearGradient(0,0,1,256);var a=1/(r.length-1);for(let e=0,t=r.length;e<t;++e)i.addColorStop(e*a,r[e]);return e.fillStyle=i,e.fillRect(0,0,1,256),e.canvas}export default Heatmap;