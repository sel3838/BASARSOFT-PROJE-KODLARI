import Collection from"../Collection.js";import CollectionEventType from"../CollectionEventType.js";import Event from"../events/Event.js";import EventType from"../events/EventType.js";import Feature from"../Feature.js";import MapBrowserEventType from"../MapBrowserEventType.js";import Point from"../geom/Point.js";import PointerInteraction from"./Pointer.js";import RBush from"../structs/RBush.js";import VectorEventType from"../source/VectorEventType.js";import VectorLayer from"../layer/Vector.js";import VectorSource from"../source/Vector.js";import{altKeyOnly,always,primaryAction,singleClick}from"../events/condition.js";import{boundingExtent,buffer as bufferExtent,createOrUpdateFromCoordinate as createExtent}from"../extent.js";import{closestOnSegment,distance as coordinateDistance,equals as coordinatesEqual,squaredDistance as squaredCoordinateDistance,squaredDistanceToSegment}from"../coordinate.js";import{createEditingStyle}from"../style/Style.js";import{equals}from"../array.js";import{fromCircle}from"../geom/Polygon.js";import{fromUserCoordinate,fromUserExtent,getUserProjection,toUserCoordinate,toUserExtent}from"../proj.js";import{getUid}from"../util.js";const CIRCLE_CENTER_INDEX=0,CIRCLE_CIRCUMFERENCE_INDEX=1,tempExtent=[0,0,0,0],tempSegment=[],ModifyEventType={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};class ModifyEvent extends Event{constructor(e,t,i){super(e),this.features=t,this.mapBrowserEvent=i}}class Modify extends PointerInteraction{constructor(e){super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition||primaryAction,this.defaultDeleteCondition_=function(e){return altKeyOnly(e)&&singleClick(e)},this.deleteCondition_=e.deleteCondition||this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition||always,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new RBush,this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new VectorLayer({source:new VectorSource({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style||getDefaultStyleFunction(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null;let t;if(e.features?t=e.features:e.source&&(this.source_=e.source,t=new Collection(this.source_.getFeatures()),this.source_.addEventListener(VectorEventType.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(VectorEventType.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(CollectionEventType.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(CollectionEventType.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=void 0===e.snapToPointer?!this.hitDetection_:e.snapToPointer}addFeature_(e){const t=e.getGeometry();if(t){const r=this.SEGMENT_WRITERS_[t.getType()];r&&r(e,t)}const i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,i),e.addEventListener(EventType.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,i){if(!this.featuresBeingModified_){this.featuresBeingModified_=new Collection;const o=this.featuresBeingModified_.getArray();for(let e=0,t=i.length;e<t;++e){var r=i[e];for(let e=0,t=r.length;e<t;++e){var n=r[e].feature;n&&!o.includes(n)&&this.featuresBeingModified_.push(n)}}0===this.featuresBeingModified_.getLength()?this.featuresBeingModified_=null:this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&0===this.features_.getLength()&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(EventType.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(t){const i=this.rBush_,r=[];i.forEach(function(e){t===e.feature&&r.push(e)});for(let e=r.length-1;0<=e;--e){var n=r[e];for(let e=this.dragSegments_.length-1;0<=e;--e)this.dragSegments_[e][0]===n&&this.dragSegments_.splice(e,1);i.remove(n)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){this.changingFeature_||(e=e.target,this.removeFeature_(e),this.addFeature_(e))}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){var i=t.getCoordinates(),e={feature:e,geometry:t,segment:[i,i]};this.rBush_.insert(t.getExtent(),e)}writeMultiPointGeometry_(i,r){var n=r.getCoordinates();for(let e=0,t=n.length;e<t;++e){var o=n[e],o={feature:i,geometry:r,depth:[e],index:e,segment:[o,o]};this.rBush_.insert(r.getExtent(),o)}}writeLineStringGeometry_(i,r){const n=r.getCoordinates();for(let e=0,t=n.length-1;e<t;++e){var o=n.slice(e,e+2),s={feature:i,geometry:r,index:e,segment:o};this.rBush_.insert(boundingExtent(o),s)}}writeMultiLineStringGeometry_(r,n){var t=n.getCoordinates();for(let i=0,e=t.length;i<e;++i){const a=t[i];for(let e=0,t=a.length-1;e<t;++e){var o=a.slice(e,e+2),s={feature:r,geometry:n,depth:[i],index:e,segment:o};this.rBush_.insert(boundingExtent(o),s)}}}writePolygonGeometry_(r,n){var t=n.getCoordinates();for(let i=0,e=t.length;i<e;++i){const a=t[i];for(let e=0,t=a.length-1;e<t;++e){var o=a.slice(e,e+2),s={feature:r,geometry:n,depth:[i],index:e,segment:o};this.rBush_.insert(boundingExtent(o),s)}}}writeMultiPolygonGeometry_(n,o){var t=o.getCoordinates();for(let r=0,e=t.length;r<e;++r){var s=t[r];for(let i=0,e=s.length;i<e;++i){const g=s[i];for(let e=0,t=g.length-1;e<t;++e){var a=g.slice(e,e+2),h={feature:n,geometry:o,depth:[i,r],index:e,segment:a};this.rBush_.insert(boundingExtent(a),h)}}}}writeCircleGeometry_(e,t){var i=t.getCenter();const r={feature:e,geometry:t,index:CIRCLE_CENTER_INDEX,segment:[i,i]},n={feature:e,geometry:t,index:CIRCLE_CIRCUMFERENCE_INDEX,segment:[i,i]};e=[r,n];r.featureSegments=e,n.featureSegments=e,this.rBush_.insert(createExtent(i),r);let o=t;e=getUserProjection();e&&this.getMap()&&(i=this.getMap().getView().getProjection(),o=o.clone().transform(e,i),o=fromCircle(o).transform(i,e)),this.rBush_.insert(o.getExtent(),n)}writeGeometryCollectionGeometry_(t,i){var r=i.getGeometriesArray();for(let e=0;e<r.length;++e){const i=r[e],n=this.SEGMENT_WRITERS_[i.getType()];n(t,i)}}createOrUpdateVertexFeature_(e,t,i){let r=this.vertexFeature_;if(r){const n=r.getGeometry();n.setCoordinates(e)}else r=new Feature(new Point(e)),this.vertexFeature_=r,this.overlay_.getSource().addFeature(r);return r.set("features",t),r.set("geometries",i),r}handleEvent(e){if(!e.originalEvent)return!0;let t;return(this.lastPointerEvent_=e).map.getView().getInteracting()||e.type!=MapBrowserEventType.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(t=!(e.type!=MapBrowserEventType.SINGLECLICK||!this.ignoreNextSingleClick_)||this.removePoint()),e.type==MapBrowserEventType.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}handleDragEvent(i){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(i,this.dragSegments_);const r=[i.coordinate[0]+this.delta_[0],i.coordinate[1]+this.delta_[1]],n=[],o=[];for(let t=0,e=this.dragSegments_.length;t<e;++t){var s=this.dragSegments_[t],a=s[0],h=a.feature;n.includes(h)||n.push(h);const c=a.geometry;o.includes(c)||o.push(c);var g=a.depth;let e;const m=a.segment;for(var d=s[1];r.length<c.getStride();)r.push(m[d][r.length]);switch(c.getType()){case"Point":e=r,m[0]=r,m[1]=r;break;case"MultiPoint":(e=c.getCoordinates())[a.index]=r,m[0]=r,m[1]=r;break;case"LineString":(e=c.getCoordinates())[a.index+d]=r,m[d]=r;break;case"MultiLineString":case"Polygon":(e=c.getCoordinates())[g[0]][a.index+d]=r,m[d]=r;break;case"MultiPolygon":(e=c.getCoordinates())[g[1]][g[0]][a.index+d]=r,m[d]=r;break;case"Circle":if(m[0]=r,m[1]=r,a.index===CIRCLE_CENTER_INDEX)this.changingFeature_=!0,c.setCenter(r),this.changingFeature_=!1;else{this.changingFeature_=!0;var l=i.map.getView().getProjection();let e=coordinateDistance(fromUserCoordinate(c.getCenter(),l),fromUserCoordinate(r,l));var u=getUserProjection();if(u){const _=c.clone().transform(u,l);_.setRadius(e),e=_.transform(l,u).getRadius()}c.setRadius(e),this.changingFeature_=!1}}e&&this.setGeometryCoordinates_(c,e)}this.createOrUpdateVertexFeature_(r,n,o)}handleDownEvent(i){if(!this.condition_(i))return!1;var r=i.coordinate;this.handlePointerAtPixel_(i.pixel,i.map,r),this.dragSegments_.length=0,this.featuresBeingModified_=null;const e=this.vertexFeature_;if(e){var n=i.map.getView().getProjection();const h=[];var o=e.getGeometry().getCoordinates(),t=boundingExtent([o]);const g=this.rBush_.getInExtent(t),d={};g.sort(compareIndexes);for(let t=0,e=g.length;t<e;++t){const l=g[t];var s=l.segment;let e=getUid(l.geometry);const u=l.depth;if(u&&(e+="-"+u.join("-")),d[e]||(d[e]=new Array(2)),"Circle"===l.geometry.getType()&&l.index===CIRCLE_CIRCUMFERENCE_INDEX){var a=closestOnSegmentData(r,l,n);coordinatesEqual(a,o)&&!d[e][0]&&(this.dragSegments_.push([l,0]),d[e][0]=l)}else if(coordinatesEqual(s[0],o)&&!d[e][0])this.dragSegments_.push([l,0]),d[e][0]=l;else if(coordinatesEqual(s[1],o)&&!d[e][1]){if(d[e][0]&&0===d[e][0].index){let e=l.geometry.getCoordinates();switch(l.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":e=e[u[1]];case"Polygon":if(l.index!==e[u[0]].length-2)continue}}this.dragSegments_.push([l,1]),d[e][1]=l}else getUid(s)in this.vertexSegments_&&!d[e][0]&&!d[e][1]&&this.insertVertexCondition_(i)&&h.push(l)}h.length&&this.willModifyFeatures_(i,[h]);for(let e=h.length-1;0<=e;--e)this.insertVertex_(h[e],o)}return!!this.vertexFeature_}handleUpEvent(t){for(let e=this.dragSegments_.length-1;0<=e;--e){var i=this.dragSegments_[e][0];const o=i.geometry;if("Circle"===o.getType()){var r=o.getCenter();const s=i.featureSegments[0],a=i.featureSegments[1];s.segment[0]=r,s.segment[1]=r,a.segment[0]=r,a.segment[1]=r,this.rBush_.update(createExtent(r),s);let e=o;var n,r=getUserProjection();r&&(n=t.map.getView().getProjection(),e=e.clone().transform(r,n),e=fromCircle(e).transform(n,r)),this.rBush_.update(e.getExtent(),a)}else this.rBush_.update(boundingExtent(i.segment),i)}return this.featuresBeingModified_&&(this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND,this.featuresBeingModified_,t)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.pixel,e.map,e.coordinate)}handlePointerAtPixel_(i,r,n){const o=n||r.getCoordinateFromPixel(i),s=r.getView().getProjection();let a,h;if(this.hitDetection_&&(n="object"==typeof this.hitDetection_?e=>e===this.hitDetection_:void 0,r.forEachFeatureAtPixel(i,(e,t,i)=>{var i=(i=i&&"Point"===i.getType()?new Point(toUserCoordinate(i.getCoordinates(),s)):i)||e.getGeometry();return e instanceof Feature&&this.features_.getArray().includes(e)&&(h=i,i=e.getGeometry().getFlatCoordinates().slice(0,2),a=[{feature:e,geometry:h,segment:[i,i]}]),!0},{layerFilter:n})),a||(n=fromUserExtent(createExtent(o,tempExtent),s),d=r.getView().getResolution()*this.pixelTolerance_,n=toUserExtent(bufferExtent(n,d,tempExtent),s),a=this.rBush_.getInExtent(n)),a&&0<a.length){const c=a.sort(function(e,t){return projectedDistanceToSegmentDataSquared(o,e,s)-projectedDistanceToSegmentDataSquared(o,t,s)})[0];var g=c.segment;let e=closestOnSegmentData(o,c,s);var d=r.getPixelFromCoordinate(e);let t=coordinateDistance(i,d);if(h||t<=this.pixelTolerance_){const m={};if(m[getUid(g)]=!0,this.snapToPointer_||(this.delta_[0]=e[0]-o[0],this.delta_[1]=e[1]-o[1]),"Circle"===c.geometry.getType()&&c.index===CIRCLE_CIRCUMFERENCE_INDEX)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(e,[c.feature],[c.geometry]);else{n=r.getPixelFromCoordinate(g[0]),i=r.getPixelFromCoordinate(g[1]),r=squaredCoordinateDistance(d,n),n=squaredCoordinateDistance(d,i);t=Math.sqrt(Math.min(r,n)),this.snappedToVertex_=t<=this.pixelTolerance_,this.snappedToVertex_&&(e=n<r?g[1]:g[0]),this.createOrUpdateVertexFeature_(e,[c.feature],[c.geometry]);const _={};_[getUid(c.geometry)]=!0;for(let e=1,t=a.length;e<t;++e){var l=a[e].segment;if(!(coordinatesEqual(g[0],l[0])&&coordinatesEqual(g[1],l[1])||coordinatesEqual(g[0],l[1])&&coordinatesEqual(g[1],l[0])))break;var u=getUid(a[e].geometry);u in _||(_[u]=!0,m[getUid(l)]=!0)}}return void(this.vertexSegments_=m)}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){var i=e.segment,r=e.feature;const n=e.geometry;var o=e.depth,s=e.index;let a;for(;t.length<n.getStride();)t.push(0);switch(n.getType()){case"MultiLineString":case"Polygon":(a=n.getCoordinates())[o[0]].splice(s+1,0,t);break;case"MultiPolygon":(a=n.getCoordinates())[o[1]][o[0]].splice(s+1,0,t);break;case"LineString":(a=n.getCoordinates()).splice(s+1,0,t);break;default:return}this.setGeometryCoordinates_(n,a);const h=this.rBush_;h.remove(e),this.updateSegmentIndices_(n,s,o,1);e={segment:[i[0],t],feature:r,geometry:n,depth:o,index:s},h.insert(boundingExtent(e.segment),e),this.dragSegments_.push([e,1]),e={segment:[t,i[1]],feature:r,geometry:n,depth:o,index:s+1};h.insert(boundingExtent(e.segment),e),this.dragSegments_.push([e,0]),this.ignoreNextSingleClick_=!0}removePoint(){var e,t;return!(!this.lastPointerEvent_||this.lastPointerEvent_.type==MapBrowserEventType.POINTERDRAG)&&(e=this.lastPointerEvent_,this.willModifyFeatures_(e,this.dragSegments_),t=this.removeVertex_(),this.featuresBeingModified_&&this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null,t)}removeVertex_(){const e=this.dragSegments_,t={};let i=!1,r,n,o,s,a,h,g,d,l,u,c;for(a=e.length-1;0<=a;--a)o=e[a],u=o[0],c=getUid(u.feature),u.depth&&(c+="-"+u.depth.join("-")),c in t||(t[c]={}),0===o[1]?(t[c].right=u,t[c].index=u.index):1==o[1]&&(t[c].left=u,t[c].index=u.index+1);for(c in t){switch(l=t[c].right,g=t[c].left,h=t[c].index,d=h-1,u=void 0!==g?g:l,d<0&&(d=0),s=u.geometry,n=s.getCoordinates(),r=n,i=!1,s.getType()){case"MultiLineString":2<n[u.depth[0]].length&&(n[u.depth[0]].splice(h,1),i=!0);break;case"LineString":2<n.length&&(n.splice(h,1),i=!0);break;case"MultiPolygon":r=r[u.depth[1]];case"Polygon":4<(r=r[u.depth[0]]).length&&(h==r.length-1&&(h=0),r.splice(h,1),i=!0,0===h&&(r.pop(),r.push(r[0]),d=r.length-1))}if(i){this.setGeometryCoordinates_(s,n);const _=[];var m;void 0!==g&&(this.rBush_.remove(g),_.push(g.segment[0])),void 0!==l&&(this.rBush_.remove(l),_.push(l.segment[1])),void 0!==g&&void 0!==l&&(m={depth:u.depth,feature:u.feature,geometry:u.geometry,index:d,segment:_},this.rBush_.insert(boundingExtent(m.segment),m)),this.updateSegmentIndices_(s,h,u.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return i}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(t,i,r,n){this.rBush_.forEachInExtent(t.getExtent(),function(e){e.geometry===t&&(void 0===r||void 0===e.depth||equals(e.depth,r))&&e.index>i&&(e.index+=n)})}}function compareIndexes(e,t){return e.index-t.index}function projectedDistanceToSegmentDataSquared(t,i,r){const n=i.geometry;if("Circle"===n.getType()){let e=n;if(i.index===CIRCLE_CIRCUMFERENCE_INDEX)return(o=getUserProjection())&&(e=e.clone().transform(o,r)),o=squaredCoordinateDistance(e.getCenter(),fromUserCoordinate(t,r)),(o=Math.sqrt(o)-e.getRadius())*o}var o=fromUserCoordinate(t,r);return tempSegment[0]=fromUserCoordinate(i.segment[0],r),tempSegment[1]=fromUserCoordinate(i.segment[1],r),squaredDistanceToSegment(o,tempSegment)}function closestOnSegmentData(t,e,i){const r=e.geometry;if("Circle"===r.getType()&&e.index===CIRCLE_CIRCUMFERENCE_INDEX){let e=r;var n=getUserProjection();return n&&(e=e.clone().transform(n,i)),toUserCoordinate(e.getClosestPoint(fromUserCoordinate(t,i)),i)}n=fromUserCoordinate(t,i);return tempSegment[0]=fromUserCoordinate(e.segment[0],i),tempSegment[1]=fromUserCoordinate(e.segment[1],i),toUserCoordinate(closestOnSegment(n,tempSegment),i)}function getDefaultStyleFunction(){const i=createEditingStyle();return function(e,t){return i.Point}}export default Modify;export{ModifyEvent};