import CollectionEventType from"../CollectionEventType.js";import EventType from"../events/EventType.js";import PointerInteraction from"./Pointer.js";import RBush from"../structs/RBush.js";import VectorEventType from"../source/VectorEventType.js";import{FALSE,TRUE}from"../functions.js";import{SnapEvent,SnapEventType}from"../events/SnapEvent.js";import{boundingExtent,buffer,createEmpty}from"../extent.js";import{closestOnCircle,closestOnSegment,squaredDistance}from"../coordinate.js";import{fromCircle}from"../geom/Polygon.js";import{fromUserCoordinate,getUserProjection,toUserCoordinate,toUserExtent}from"../proj.js";import{getUid}from"../util.js";import{listen,unlistenByKey}from"../events.js";function getFeatureFromEvent(e){return e.feature||e.element||null}const tempSegment=[];class Snap extends PointerInteraction{constructor(e){const t=e=e||{};t.handleDownEvent||(t.handleDownEvent=TRUE),t.stopDown||(t.stopDown=FALSE),super(t),this.on,this.once,this.un,this.source_=e.source||null,this.vertex_=void 0===e.vertex||e.vertex,this.edge_=void 0===e.edge||e.edge,this.features_=e.features||null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.rBush_=new RBush,this.GEOMETRY_SEGMENTERS_={Point:this.segmentPointGeometry_.bind(this),LineString:this.segmentLineStringGeometry_.bind(this),LinearRing:this.segmentLineStringGeometry_.bind(this),Polygon:this.segmentPolygonGeometry_.bind(this),MultiPoint:this.segmentMultiPointGeometry_.bind(this),MultiLineString:this.segmentMultiLineStringGeometry_.bind(this),MultiPolygon:this.segmentMultiPolygonGeometry_.bind(this),GeometryCollection:this.segmentGeometryCollectionGeometry_.bind(this),Circle:this.segmentCircleGeometry_.bind(this)}}addFeature(t,e){e=void 0===e||e;var n,r,s=getUid(t);const i=t.getGeometry();if(i){const o=this.GEOMETRY_SEGMENTERS_[i.getType()];if(o){this.indexedFeaturesExtents_[s]=i.getExtent(createEmpty());const a=[];o(a,i),1===a.length?this.rBush_.insert(boundingExtent(a[0]),{feature:t,segment:a[0]}):1<a.length&&(n=a.map(e=>boundingExtent(e)),r=a.map(e=>({feature:t,segment:e})),this.rBush_.load(n,r))}}e&&(this.featureChangeListenerKeys_[s]=listen(t,EventType.CHANGE,this.handleFeatureChange_,this))}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t&&(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel,this.dispatchEvent(new SnapEvent(SnapEventType.SNAP,{vertex:e.coordinate,vertexPixel:e.pixel,feature:t.feature,segment:t.segment}))),super.handleEvent(e)}handleFeatureAdd_(e){e=getFeatureFromEvent(e);e&&this.addFeature(e)}handleFeatureRemove_(e){e=getFeatureFromEvent(e);e&&this.removeFeature(e)}handleFeatureChange_(e){var t,e=e.target;this.handlingDownUpSequence?(t=getUid(e))in this.pendingFeatures_||(this.pendingFeatures_[t]=e):this.updateFeature_(e)}handleUpEvent(e){const t=Object.values(this.pendingFeatures_);return t.length&&(t.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1}removeFeature(t,e){var e=void 0===e||e,n=getUid(t),r=this.indexedFeaturesExtents_[n];if(r){const s=this.rBush_,i=[];s.forEachInExtent(r,function(e){t===e.feature&&i.push(e)});for(let e=i.length-1;0<=e;--e)s.remove(i[e])}e&&(unlistenByKey(this.featureChangeListenerKeys_[n]),delete this.featureChangeListenerKeys_[n])}setMap(e){var t=this.getMap();const n=this.featuresListenerKeys_,r=this.getFeatures_();t&&(n.forEach(unlistenByKey),n.length=0,this.rBush_.clear(),Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey),this.featureChangeListenerKeys_={}),super.setMap(e),e&&(this.features_?n.push(listen(this.features_,CollectionEventType.ADD,this.handleFeatureAdd_,this),listen(this.features_,CollectionEventType.REMOVE,this.handleFeatureRemove_,this)):this.source_&&n.push(listen(this.source_,VectorEventType.ADDFEATURE,this.handleFeatureAdd_,this),listen(this.source_,VectorEventType.REMOVEFEATURE,this.handleFeatureRemove_,this)),r.forEach(e=>this.addFeature(e)))}snapTo(t,e,n){const r=n.getView().getProjection(),s=fromUserCoordinate(e,r);var e=toUserExtent(buffer(boundingExtent([s]),n.getView().getResolution()*this.pixelTolerance_),r),i=this.rBush_.getInExtent(e),o=i.length;if(0===o)return null;let a,l=1/0,h,u=null;const g=this.pixelTolerance_*this.pixelTolerance_;e=()=>{if(a){var e=n.getPixelFromCoordinate(a);if(squaredDistance(t,e)<=g)return{vertex:a,vertexPixel:[Math.round(e[0]),Math.round(e[1])],feature:h,segment:u}}return null};if(this.vertex_){for(let e=0;e<o;++e){const f=i[e];"Circle"!==f.feature.getGeometry().getType()&&f.segment.forEach(e=>{var t=fromUserCoordinate(e,r),t=squaredDistance(s,t);t<l&&(a=e,l=t,h=f.feature)})}var m=e();if(m)return m}if(this.edge_){for(let e=0;e<o;++e){let t=null;const p=i[e];if("Circle"===p.feature.getGeometry().getType()){let e=p.feature.getGeometry();var c=getUserProjection();c&&(e=e.clone().transform(c,r)),t=closestOnCircle(s,e)}else{var[c,d]=p.segment;d&&(tempSegment[0]=fromUserCoordinate(c,r),tempSegment[1]=fromUserCoordinate(d,r),t=closestOnSegment(s,tempSegment))}!t||(d=squaredDistance(s,t))<l&&(a=toUserCoordinate(t,r),u="Circle"===p.feature.getGeometry().getType()?null:p.segment,l=d,h=p.feature)}m=e();if(m)return m}return null}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}segmentCircleGeometry_(n,e){var t=this.getMap().getView().getProjection();let r=e;e=getUserProjection();e&&(r=r.clone().transform(e,t));const s=fromCircle(r),i=(e&&s.transform(t,e),s.getCoordinates()[0]);for(let e=0,t=i.length-1;e<t;++e)n.push(i.slice(e,e+2))}segmentGeometryCollectionGeometry_(t,e){const n=e.getGeometriesArray();for(let e=0;e<n.length;++e){const r=this.GEOMETRY_SEGMENTERS_[n[e].getType()];r&&r(t,n[e])}}segmentLineStringGeometry_(n,e){const r=e.getCoordinates();for(let e=0,t=r.length-1;e<t;++e)n.push(r.slice(e,e+2))}segmentMultiLineStringGeometry_(n,e){var r=e.getCoordinates();for(let e=0,t=r.length;e<t;++e){const s=r[e];for(let e=0,t=s.length-1;e<t;++e)n.push(s.slice(e,e+2))}}segmentMultiPointGeometry_(t,e){e.getCoordinates().forEach(e=>{t.push([e])})}segmentMultiPolygonGeometry_(n,e){var r=e.getCoordinates();for(let e=0,t=r.length;e<t;++e){var s=r[e];for(let e=0,t=s.length;e<t;++e){const i=s[e];for(let e=0,t=i.length-1;e<t;++e)n.push(i.slice(e,e+2))}}}segmentPointGeometry_(e,t){e.push([t.getCoordinates()])}segmentPolygonGeometry_(n,e){var r=e.getCoordinates();for(let e=0,t=r.length;e<t;++e){const s=r[e];for(let e=0,t=s.length-1;e<t;++e)n.push(s.slice(e,e+2))}}}export default Snap;