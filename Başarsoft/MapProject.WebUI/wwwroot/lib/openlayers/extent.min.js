import Relationship from"./extent/Relationship.js";function boundingExtent(n){var r=createEmpty();for(let t=0,e=n.length;t<e;++t)extendCoordinate(r,n[t]);return r}function _boundingExtentXYs(t,e,n){return createOrUpdate(Math.min.apply(null,t),Math.min.apply(null,e),Math.max.apply(null,t),Math.max.apply(null,e),n)}function buffer(t,e,n){return n?(n[0]=t[0]-e,n[1]=t[1]-e,n[2]=t[2]+e,n[3]=t[3]+e,n):[t[0]-e,t[1]-e,t[2]+e,t[3]+e]}function clone(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e):t.slice()}function closestSquaredDistanceXY(t,e,n){let r,i;return r=e<t[0]?t[0]-e:t[2]<e?e-t[2]:0,i=n<t[1]?t[1]-n:t[3]<n?n-t[3]:0,r*r+i*i}function containsCoordinate(t,e){return containsXY(t,e[0],e[1])}function containsExtent(t,e){return t[0]<=e[0]&&e[2]<=t[2]&&t[1]<=e[1]&&e[3]<=t[3]}function containsXY(t,e,n){return t[0]<=e&&e<=t[2]&&t[1]<=n&&n<=t[3]}function coordinateRelationship(t,e){var n=t[0],r=t[1],i=t[2],t=t[3],o=e[0],e=e[1];let a=Relationship.UNKNOWN;return o<n?a|=Relationship.LEFT:i<o&&(a|=Relationship.RIGHT),e<r?a|=Relationship.BELOW:t<e&&(a|=Relationship.ABOVE),a=a===Relationship.UNKNOWN?Relationship.INTERSECTING:a}function createEmpty(){return[1/0,1/0,-1/0,-1/0]}function createOrUpdate(t,e,n,r,i){return i?(i[0]=t,i[1]=e,i[2]=n,i[3]=r,i):[t,e,n,r]}function createOrUpdateEmpty(t){return createOrUpdate(1/0,1/0,-1/0,-1/0,t)}function createOrUpdateFromCoordinate(t,e){var n=t[0],t=t[1];return createOrUpdate(n,t,n,t,e)}function createOrUpdateFromCoordinates(t,e){return extendCoordinates(createOrUpdateEmpty(e),t)}function createOrUpdateFromFlatCoordinates(t,e,n,r,i){return extendFlatCoordinates(createOrUpdateEmpty(i),t,e,n,r)}function createOrUpdateFromRings(t,e){return extendRings(createOrUpdateEmpty(e),t)}function equals(t,e){return t[0]==e[0]&&t[2]==e[2]&&t[1]==e[1]&&t[3]==e[3]}function approximatelyEquals(t,e,n){return Math.abs(t[0]-e[0])<n&&Math.abs(t[2]-e[2])<n&&Math.abs(t[1]-e[1])<n&&Math.abs(t[3]-e[3])<n}function extend(t,e){return e[0]<t[0]&&(t[0]=e[0]),e[2]>t[2]&&(t[2]=e[2]),e[1]<t[1]&&(t[1]=e[1]),e[3]>t[3]&&(t[3]=e[3]),t}function extendCoordinate(t,e){e[0]<t[0]&&(t[0]=e[0]),e[0]>t[2]&&(t[2]=e[0]),e[1]<t[1]&&(t[1]=e[1]),e[1]>t[3]&&(t[3]=e[1])}function extendCoordinates(n,r){for(let t=0,e=r.length;t<e;++t)extendCoordinate(n,r[t]);return n}function extendFlatCoordinates(t,e,n,r,i){for(;n<r;n+=i)extendXY(t,e[n],e[n+1]);return t}function extendRings(n,r){for(let t=0,e=r.length;t<e;++t)extendCoordinates(n,r[t]);return n}function extendXY(t,e,n){t[0]=Math.min(t[0],e),t[1]=Math.min(t[1],n),t[2]=Math.max(t[2],e),t[3]=Math.max(t[3],n)}function forEachCorner(t,e){let n;return((n=e(getBottomLeft(t)))||(n=e(getBottomRight(t)))||(n=e(getTopRight(t)))||!!(n=e(getTopLeft(t))))&&n}function getArea(t){let e=0;return e=isEmpty(t)?e:getWidth(t)*getHeight(t)}function getBottomLeft(t){return[t[0],t[1]]}function getBottomRight(t){return[t[2],t[1]]}function getCenter(t){return[(t[0]+t[2])/2,(t[1]+t[3])/2]}function getCorner(t,e){let n;if("bottom-left"===e)n=getBottomLeft(t);else if("bottom-right"===e)n=getBottomRight(t);else if("top-left"===e)n=getTopLeft(t);else{if("top-right"!==e)throw new Error("Invalid corner");n=getTopRight(t)}return n}function getEnlargedArea(t,e){var n=Math.min(t[0],e[0]),r=Math.min(t[1],e[1]);return(Math.max(t[2],e[2])-n)*(Math.max(t[3],e[3])-r)}function getForViewAndSize(t,e,n,r,i){var[t,e,n,r,o,a,u,c]=getRotatedViewport(t,e,n,r);return createOrUpdate(Math.min(t,n,o,u),Math.min(e,r,a,c),Math.max(t,n,o,u),Math.max(e,r,a,c),i)}function getRotatedViewport(t,e,n,r){var i=e*r[0]/2,e=e*r[1]/2,r=Math.cos(n),n=Math.sin(n),o=i*r,i=i*n,r=e*r,e=e*n,n=t[0],t=t[1];return[n-o+e,t-i-r,n-o-e,t-i+r,n+o-e,t+i+r,n+o+e,t+i-r,n-o+e,t-i-r]}function getHeight(t){return t[3]-t[1]}function getIntersectionArea(t,e){return getArea(getIntersection(t,e))}function getIntersection(t,e,n){const r=n||createEmpty();return intersects(t,e)?(t[0]>e[0]?r[0]=t[0]:r[0]=e[0],t[1]>e[1]?r[1]=t[1]:r[1]=e[1],t[2]<e[2]?r[2]=t[2]:r[2]=e[2],t[3]<e[3]?r[3]=t[3]:r[3]=e[3]):createOrUpdateEmpty(r),r}function getMargin(t){return getWidth(t)+getHeight(t)}function getSize(t){return[t[2]-t[0],t[3]-t[1]]}function getTopLeft(t){return[t[0],t[3]]}function getTopRight(t){return[t[2],t[3]]}function getWidth(t){return t[2]-t[0]}function intersects(t,e){return t[0]<=e[2]&&t[2]>=e[0]&&t[1]<=e[3]&&t[3]>=e[1]}function isEmpty(t){return t[2]<t[0]||t[3]<t[1]}function returnOrUpdate(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e):t}function scaleFromCenter(t,e){var n=(t[2]-t[0])/2*(e-1),e=(t[3]-t[1])/2*(e-1);t[0]-=n,t[2]+=n,t[1]-=e,t[3]+=e}function intersectsSegment(n,r,i){let o=!1;var a=coordinateRelationship(n,r),u=coordinateRelationship(n,i);if(a===Relationship.INTERSECTING||u===Relationship.INTERSECTING)o=!0;else{var c=n[0],p=n[1],s=n[2],n=n[3],d=r[0],r=r[1],f=i[0],i=i[1],r=(i-r)/(f-d);let t,e;u&Relationship.ABOVE&&!(a&Relationship.ABOVE)&&(t=f-(i-n)/r,o=t>=c&&t<=s),o||!(u&Relationship.RIGHT)||a&Relationship.RIGHT||(e=i-(f-s)*r,o=e>=p&&e<=n),o||!(u&Relationship.BELOW)||a&Relationship.BELOW||(t=f-(i-p)/r,o=t>=c&&t<=s),o||!(u&Relationship.LEFT)||a&Relationship.LEFT||(e=i-(f-c)*r,o=e>=p&&e<=n)}return o}function applyTransform(e,t,n,r){if(isEmpty(e))return createOrUpdateEmpty(n);let i=[];if(1<r){var o=e[2]-e[0],a=e[3]-e[1];for(let t=0;t<r;++t)i.push(e[0]+o*t/r,e[1],e[2],e[1]+a*t/r,e[2]-o*t/r,e[3],e[0],e[3]-a*t/r)}else i=[e[0],e[1],e[2],e[1],e[2],e[3],e[0],e[3]];t(i,i,2);const u=[],c=[];for(let t=0,e=i.length;t<e;t+=2)u.push(i[t]),c.push(i[t+1]);return _boundingExtentXYs(u,c,n)}function wrapX(t,e){var n=e.getExtent(),r=getCenter(t);return e.canWrapX()&&(r[0]<n[0]||r[0]>=n[2])&&(e=getWidth(n),r=Math.floor((r[0]-n[0])/e)*e,t[0]-=r,t[2]-=r),t}function wrapAndSliceX(t,e,n){if(e.canWrapX()){var r=e.getExtent();if(!isFinite(t[0])||!isFinite(t[2]))return[[r[0],t[1],r[2],t[3]]];wrapX(t,e);e=getWidth(r);if(getWidth(t)>e&&!n)return[[r[0],t[1],r[2],t[3]]];if(t[0]<r[0])return[[t[0]+e,t[1],r[2],t[3]],[r[0],t[1],t[2],t[3]]];if(t[2]>r[2])return[[t[0],t[1],r[2],t[3]],[r[0],t[1],t[2]-e,t[3]]]}return[t]}export{boundingExtent,buffer,clone,closestSquaredDistanceXY,containsCoordinate,containsExtent,containsXY,coordinateRelationship,createEmpty,createOrUpdate,createOrUpdateEmpty,createOrUpdateFromCoordinate,createOrUpdateFromCoordinates,createOrUpdateFromFlatCoordinates,createOrUpdateFromRings,equals,approximatelyEquals,extend,extendCoordinate,extendCoordinates,extendFlatCoordinates,extendRings,extendXY,forEachCorner,getArea,getBottomLeft,getBottomRight,getCenter,getCorner,getEnlargedArea,getForViewAndSize,getRotatedViewport,getHeight,getIntersectionArea,getIntersection,getMargin,getSize,getTopLeft,getTopRight,getWidth,intersects,isEmpty,returnOrUpdate,scaleFromCenter,intersectsSegment,applyTransform,wrapX,wrapAndSliceX};