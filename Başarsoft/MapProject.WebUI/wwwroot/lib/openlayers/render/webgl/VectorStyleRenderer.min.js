import WebGLArrayBuffer from"../../webgl/Buffer.js";import{ARRAY_BUFFER,DYNAMIC_DRAW,ELEMENT_ARRAY_BUFFER}from"../../webgl.js";import{AttributeType}from"../../webgl/Helper.js";import{WebGLWorkerMessageType}from"./constants.js";import{colorEncodeId}from"./utils.js";import{create as createTransform,makeInverse as makeInverseTransform}from"../../transform.js";import{create as createWebGLWorker}from"../../worker/webgl.js";import{generateLineStringRenderInstructions,generatePointRenderInstructions,generatePolygonRenderInstructions,getCustomAttributesSize}from"./renderinstructions.js";import{parseLiteralStyle}from"../../webgl/styleparser.js";const tmpColor=[],WEBGL_WORKER=createWebGLWorker();let workerMessageCounter=0;const Attributes={POSITION:"a_position",INDEX:"a_index",SEGMENT_START:"a_segmentStart",SEGMENT_END:"a_segmentEnd",PARAMETERS:"a_parameters",JOIN_ANGLES:"a_joinAngles",DISTANCE:"a_distance"};class VectorStyleRenderer{constructor(e,t,r){this.helper_=t,this.hitDetectionEnabled_=r;let s=e;"builder"in e||(t=parseLiteralStyle(e),s={builder:t.builder,attributes:t.attributes,uniforms:t.uniforms}),this.hasFill_=!!s.builder.getFillVertexShader(),this.hasFill_&&(this.fillVertexShader_=s.builder.getFillVertexShader(),this.fillFragmentShader_=s.builder.getFillFragmentShader(),this.fillProgram_=this.helper_.getProgram(this.fillFragmentShader_,this.fillVertexShader_)),this.hasStroke_=!!s.builder.getStrokeVertexShader(),this.hasStroke_&&(this.strokeVertexShader_=s.builder.getStrokeVertexShader(),this.strokeFragmentShader_=s.builder.getStrokeFragmentShader(),this.strokeProgram_=this.helper_.getProgram(this.strokeFragmentShader_,this.strokeVertexShader_)),this.hasSymbol_=!!s.builder.getSymbolVertexShader(),this.hasSymbol_&&(this.symbolVertexShader_=s.builder.getSymbolVertexShader(),this.symbolFragmentShader_=s.builder.getSymbolFragmentShader(),this.symbolProgram_=this.helper_.getProgram(this.symbolFragmentShader_,this.symbolVertexShader_));r=this.hitDetectionEnabled_?{hitColor:{callback(){return colorEncodeId(this.ref,tmpColor)},size:4}}:{},this.customAttributes_=Object.assign({},r,s.attributes),this.uniforms_=s.uniforms,e=Object.entries(this.customAttributes_).map(([e,t])=>({name:"a_prop_"+e,size:t.size||1,type:AttributeType.FLOAT}));this.polygonAttributesDesc_=[{name:Attributes.POSITION,size:2,type:AttributeType.FLOAT},...e],this.lineStringAttributesDesc_=[{name:Attributes.SEGMENT_START,size:2,type:AttributeType.FLOAT},{name:Attributes.SEGMENT_END,size:2,type:AttributeType.FLOAT},{name:Attributes.JOIN_ANGLES,size:2,type:AttributeType.FLOAT},{name:Attributes.DISTANCE,size:1,type:AttributeType.FLOAT},{name:Attributes.PARAMETERS,size:1,type:AttributeType.FLOAT},...e],this.pointAttributesDesc_=[{name:Attributes.POSITION,size:2,type:AttributeType.FLOAT},{name:Attributes.INDEX,size:1,type:AttributeType.FLOAT},...e],s.uniforms&&this.helper_.addUniforms(s.uniforms)}async generateBuffers(e,t){var e=this.generateRenderInstructions_(e,t),[e,r,s]=await Promise.all([this.generateBuffersForType_(e.polygonInstructions,"Polygon",t),this.generateBuffersForType_(e.lineStringInstructions,"LineString",t),this.generateBuffersForType_(e.pointInstructions,"Point",t)]);return{polygonBuffers:e,lineStringBuffers:r,pointBuffers:s,invertVerticesTransform:makeInverseTransform(createTransform(),t)}}generateRenderInstructions_(e,t){return{polygonInstructions:this.hasFill_?generatePolygonRenderInstructions(e.polygonBatch,new Float32Array(0),this.customAttributes_,t):null,lineStringInstructions:this.hasStroke_?generateLineStringRenderInstructions(e.lineStringBatch,new Float32Array(0),this.customAttributes_,t):null,pointInstructions:this.hasSymbol_?generatePointRenderInstructions(e.pointBatch,new Float32Array(0),this.customAttributes_,t):null}}generateBuffersForType_(e,t,r){if(null===e)return null;const i=workerMessageCounter++;let s;switch(t){case"Polygon":s=WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;break;case"LineString":s=WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;break;case"Point":s=WebGLWorkerMessageType.GENERATE_POINT_BUFFERS}t={id:i,type:s,renderInstructions:e.buffer,renderInstructionsTransform:r,customAttributesSize:getCustomAttributesSize(this.customAttributes_)};return WEBGL_WORKER.postMessage(t,[e.buffer]),e=null,new Promise(r=>{const s=e=>{var t,e=e.data;e.id===i&&(WEBGL_WORKER.removeEventListener("message",s),this.helper_.getGL()&&(t=new WebGLArrayBuffer(ARRAY_BUFFER,DYNAMIC_DRAW).fromArrayBuffer(e.vertexBuffer),e=new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER,DYNAMIC_DRAW).fromArrayBuffer(e.indexBuffer),this.helper_.flushBufferData(t),this.helper_.flushBufferData(e),r([e,t])))};WEBGL_WORKER.addEventListener("message",s)})}render(e,t,r){this.hasFill_&&this.renderInternal_(e.polygonBuffers[0],e.polygonBuffers[1],this.fillProgram_,this.polygonAttributesDesc_,t,r),this.hasStroke_&&this.renderInternal_(e.lineStringBuffers[0],e.lineStringBuffers[1],this.strokeProgram_,this.lineStringAttributesDesc_,t,r),this.hasSymbol_&&this.renderInternal_(e.pointBuffers[0],e.pointBuffers[1],this.symbolProgram_,this.pointAttributesDesc_,t,r)}renderInternal_(e,t,r,s,i,n){var o=e.getSize();0!==o&&(this.helper_.useProgram(r,i),this.helper_.bindBuffer(t),this.helper_.bindBuffer(e),this.helper_.enableAttributes(s),n(),this.helper_.drawElements(0,o))}}export default VectorStyleRenderer;export{Attributes};