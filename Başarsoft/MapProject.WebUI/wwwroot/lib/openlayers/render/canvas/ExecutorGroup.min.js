import Executor from"./Executor.js";import{ascending}from"../../array.js";import{buffer,createEmpty,extendCoordinate}from"../../extent.js";import{compose as composeTransform,create as createTransform}from"../../transform.js";import{createCanvasContext2D}from"../../dom.js";import{isEmpty}from"../../obj.js";import{transform2D}from"../../geom/flat/transform.js";const ALL=["Polygon","Circle","LineString","Image","Text","Default"],DECLUTTER=["Image","Text"],NON_DECLUTTER=ALL.filter(e=>!DECLUTTER.includes(e));class ExecutorGroup{constructor(e,t,r,n,o,s,i){this.maxExtent_=e,this.overlaps_=n,this.pixelRatio_=r,this.resolution_=t,this.renderBuffer_=s,this.executorsByZIndex_={},this.hitDetectionContext_=null,this.hitDetectionTransform_=createTransform(),this.renderedContext_=null,this.deferredZIndexContexts_={},this.createExecutors_(o,i)}clip(e,t){t=this.getClipCoords(t);e.beginPath(),e.moveTo(t[0],t[1]),e.lineTo(t[2],t[3]),e.lineTo(t[4],t[5]),e.lineTo(t[6],t[7]),e.clip()}createExecutors_(t,r){for(const s in t){let e=this.executorsByZIndex_[s];void 0===e&&(e={},this.executorsByZIndex_[s]=e);var n=t[s];for(const i in n){var o=n[i];e[i]=new Executor(this.resolution_,this.pixelRatio_,this.overlaps_,o,r)}}}hasExecutors(r){for(const e in this.executorsByZIndex_){var n=this.executorsByZIndex_[e];for(let e=0,t=r.length;e<t;++e)if(r[e]in n)return!0}return!1}forEachFeatureAtCoordinate(e,t,r,c,x,d){const h=2*(c=Math.round(c))+1;var n=composeTransform(this.hitDetectionTransform_,c+.5,c+.5,1/t,-1/t,-r,-e[0],-e[1]),o=!this.hitDetectionContext_;o&&(this.hitDetectionContext_=createCanvasContext2D(h,h,void 0,{willReadFrequently:!0}));const l=this.hitDetectionContext_;l.canvas.width!==h||l.canvas.height!==h?(l.canvas.width=h,l.canvas.height=h):o||l.clearRect(0,0,h,h);let s;void 0!==this.renderBuffer_&&(s=createEmpty(),extendCoordinate(s,e),buffer(s,t*(this.renderBuffer_+c),s));const f=getPixelIndexArray(c);let u;function i(r,n,o){var s=l.getImageData(0,0,h,h).data;for(let e=0,t=f.length;e<t;e++)if(0<s[f[e]]){if(!d||"none"===o||"Image"!==u&&"Text"!==u||d.includes(r)){var i=(f[e]-3)/4,a=c-i%h,i=c-(i/h|0),a=x(r,n,a*a+i*i);if(a)return a}l.clearRect(0,0,h,h);break}}const a=Object.keys(this.executorsByZIndex_).map(Number);a.sort(ascending);let m,_,C,g,p;for(m=a.length-1;0<=m;--m){var v=a[m].toString();for(C=this.executorsByZIndex_[v],_=ALL.length-1;0<=_;--_)if(u=ALL[_],void 0!==(g=C[u])&&(p=g.executeHitDetection(l,n,r,i,s)))return p}}getClipCoords(e){var t=this.maxExtent_;if(!t)return null;var r=t[0],n=t[1],o=t[2],t=t[3],r=[r,n,r,t,o,t,o,n];return transform2D(r,0,8,2,e,r),r}isEmpty(){return isEmpty(this.executorsByZIndex_)}execute(e,t,r,n,o,s,i){const a=Object.keys(this.executorsByZIndex_).map(Number);a.sort(ascending),s=s||ALL;var c=ALL.length;let x,d,h,l,f;for(i&&a.reverse(),x=0,d=a.length;x<d;++x){var u=a[x].toString();for(f=this.executorsByZIndex_[u],h=0,l=s.length;h<l;++h){var m=s[h];const C=f[m];if(void 0!==C){const g=null===i?void 0:C.getZIndexContext(),p=g?g.getContext():e;var _=this.maxExtent_&&"Image"!==m&&"Text"!==m;_&&(p.save(),this.clip(p,r)),g&&"Text"!==m&&"Image"!==m?g.pushFunction(e=>C.execute(e,t,r,n,o,i)):C.execute(p,t,r,n,o,i),_&&p.restore(),g&&(g.offset(),m=a[x]*c+h,this.deferredZIndexContexts_[m]||(this.deferredZIndexContexts_[m]=[]),this.deferredZIndexContexts_[m].push(g))}}}this.renderedContext_=e}getDeferredZIndexContexts(){return this.deferredZIndexContexts_}getRenderedContext(){return this.renderedContext_}renderDeferred(){const r=this.deferredZIndexContexts_;var n=Object.keys(r).map(Number).sort(ascending);for(let e=0,t=n.length;e<t;++e)r[n[e]].forEach(e=>{e.draw(this.renderedContext_),e.clear()}),r[n[e]].length=0}}const circlePixelIndexArrayCache={};function getPixelIndexArray(n){if(void 0!==circlePixelIndexArrayCache[n])return circlePixelIndexArrayCache[n];var o=2*n+1,s=n*n;const i=new Array(1+s);for(let r=0;r<=n;++r)for(let t=0;t<=n;++t){var a=r*r+t*t;if(s<a)break;let e=i[a];e||(e=[],i[a]=e),e.push(4*((n+r)*o+(n+t))+3),0<r&&e.push(4*((n-r)*o+(n+t))+3),0<t&&(e.push(4*((n+r)*o+(n-t))+3),0<r&&e.push(4*((n-r)*o+(n-t))+3))}const r=[];for(let e=0,t=i.length;e<t;++e)i[e]&&r.push(...i[e]);return circlePixelIndexArrayCache[n]=r}export default ExecutorGroup;export{ALL,DECLUTTER,NON_DECLUTTER,getPixelIndexArray};