import Collection from"../Collection.js";import EventType from"../render/EventType.js";import Feature from"../Feature.js";import Fill from"../style/Fill.js";import LineString from"../geom/LineString.js";import Point from"../geom/Point.js";import Stroke from"../style/Stroke.js";import Style from"../style/Style.js";import Text from"../style/Text.js";import VectorLayer from"./Vector.js";import VectorSource from"../source/Vector.js";import{applyTransform,approximatelyEquals,containsCoordinate,containsExtent,equals,getCenter,getIntersection,getWidth,intersects,isEmpty,wrapX as wrapExtentX}from"../extent.js";import{clamp}from"../math.js";import{degreesToStringHDMS}from"../coordinate.js";import{equivalent as equivalentProjection,get as getProjection,getTransform}from"../proj.js";import{getVectorContext}from"../render.js";import{meridian,parallel}from"../geom/flat/geodesic.js";const DEFAULT_STROKE_STYLE=new Stroke({color:"rgba(0,0,0,0.2)"}),INTERVALS=[90,45,30,20,10,5,2,1,.5,20/60,10/60,5/60,2/60,1/60,30/3600,20/3600,10/3600,5/3600,2/3600,1/3600];class Graticule extends VectorLayer{constructor(t){t=t||{};const e=Object.assign({updateWhileAnimating:!0,updateWhileInteracting:!0,renderBuffer:0},t);delete e.maxLines,delete e.strokeStyle,delete e.targetSize,delete e.showLabels,delete e.lonLabelFormatter,delete e.latLabelFormatter,delete e.lonLabelPosition,delete e.latLabelPosition,delete e.lonLabelStyle,delete e.latLabelStyle,delete e.intervals,super(e),this.projection_=null,this.maxLat_=1/0,this.maxLon_=1/0,this.minLat_=-1/0,this.minLon_=-1/0,this.maxX_=1/0,this.maxY_=1/0,this.minX_=-1/0,this.minY_=-1/0,this.targetSize_=void 0!==t.targetSize?t.targetSize:100,this.maxLines_=void 0!==t.maxLines?t.maxLines:100,this.meridians_=[],this.parallels_=[],this.strokeStyle_=void 0!==t.strokeStyle?t.strokeStyle:DEFAULT_STROKE_STYLE,this.fromLonLatTransform_=void 0,this.toLonLatTransform_=void 0,this.projectionCenterLonLat_=null,this.bottomLeft_=null,this.bottomRight_=null,this.topLeft_=null,this.topRight_=null,this.meridiansLabels_=null,this.parallelsLabels_=null,t.showLabels&&(this.lonLabelFormatter_=null==t.lonLabelFormatter?degreesToStringHDMS.bind(this,"EW"):t.lonLabelFormatter,this.latLabelFormatter_=null==t.latLabelFormatter?degreesToStringHDMS.bind(this,"NS"):t.latLabelFormatter,this.lonLabelPosition_=null==t.lonLabelPosition?0:t.lonLabelPosition,this.latLabelPosition_=null==t.latLabelPosition?1:t.latLabelPosition,this.lonLabelStyleBase_=new Style({text:void 0!==t.lonLabelStyle?t.lonLabelStyle.clone():new Text({font:"12px Calibri,sans-serif",textBaseline:"bottom",fill:new Fill({color:"rgba(0,0,0,1)"}),stroke:new Stroke({color:"rgba(255,255,255,1)",width:3})})}),this.lonLabelStyle_=t=>{t=t.get("graticule_label");return this.lonLabelStyleBase_.getText().setText(t),this.lonLabelStyleBase_},this.latLabelStyleBase_=new Style({text:void 0!==t.latLabelStyle?t.latLabelStyle.clone():new Text({font:"12px Calibri,sans-serif",textAlign:"right",fill:new Fill({color:"rgba(0,0,0,1)"}),stroke:new Stroke({color:"rgba(255,255,255,1)",width:3})})}),this.latLabelStyle_=t=>{t=t.get("graticule_label");return this.latLabelStyleBase_.getText().setText(t),this.latLabelStyleBase_},this.meridiansLabels_=[],this.parallelsLabels_=[],this.addEventListener(EventType.POSTRENDER,this.drawLabels_.bind(this))),this.intervals_=void 0!==t.intervals?t.intervals:INTERVALS,this.setSource(new VectorSource({loader:this.loaderFunction.bind(this),strategy:this.strategyFunction.bind(this),features:new Collection,overlaps:!1,useSpatialIndex:!1,wrapX:t.wrapX})),this.featurePool_=[],this.lineStyle_=new Style({stroke:this.strokeStyle_}),this.loadedExtent_=null,this.renderedExtent_=null,this.renderedResolution_=null,this.setRenderOrder(null)}strategyFunction(t,e){let i=t.slice();return this.projection_&&this.getSource().getWrapX()&&wrapExtentX(i,this.projection_),this.loadedExtent_&&(approximatelyEquals(this.loadedExtent_,i,e)?i=this.loadedExtent_.slice():this.getSource().removeLoadedExtent(this.loadedExtent_)),[i]}loaderFunction(l,n,r){this.loadedExtent_=l;const o=this.getSource();var h=this.getExtent()||[-1/0,-1/0,1/0,1/0],h=getIntersection(h,l);if(!(this.renderedExtent_&&equals(this.renderedExtent_,h)&&this.renderedResolution_===n||(this.renderedExtent_=h,this.renderedResolution_=n,isEmpty(h)))){var l=getCenter(h),_=n*n/4;(!this.projection_||!equivalentProjection(this.projection_,r))&&this.updateProjectionInfo_(r),this.createGraticule_(h,l,n,_);let t=this.meridians_.length+this.parallels_.length;this.meridiansLabels_&&(t+=this.meridians_.length),this.parallelsLabels_&&(t+=this.parallels_.length);let e;for(;t>this.featurePool_.length;)e=new Feature,this.featurePool_.push(e);const m=o.getFeaturesCollection();m.clear();let i=0,a,s;for(a=0,s=this.meridians_.length;a<s;++a)(e=this.featurePool_[i++]).setGeometry(this.meridians_[a]),e.setStyle(this.lineStyle_),m.push(e);for(a=0,s=this.parallels_.length;a<s;++a)(e=this.featurePool_[i++]).setGeometry(this.parallels_[a]),e.setStyle(this.lineStyle_),m.push(e)}}addMeridian_(t,e,i,a,s,l){const n=this.getMeridian_(t,e,i,a,l);return intersects(n.getExtent(),s)&&(this.meridiansLabels_&&(e=this.lonLabelFormatter_(t),l in this.meridiansLabels_?this.meridiansLabels_[l].text=e:this.meridiansLabels_[l]={geom:new Point([]),text:e}),this.meridians_[l++]=n),l}addParallel_(t,e,i,a,s,l){const n=this.getParallel_(t,e,i,a,l);return intersects(n.getExtent(),s)&&(this.parallelsLabels_&&(e=this.latLabelFormatter_(t),l in this.parallelsLabels_?this.parallelsLabels_[l].text=e:this.parallelsLabels_[l]={geom:new Point([]),text:e}),this.parallels_[l++]=n),l}drawLabels_(t){var n=t.frameState.viewState.rotation,e=t.frameState.viewState.resolution,i=t.frameState.size,r=t.frameState.extent,o=getCenter(r);let h=r,_=(n&&(a=i[0]*e,i=i[1]*e,h=[o[0]-a/2,o[1]-i/2,o[0]+a/2,o[1]+i/2]),0),m=0,L=this.latLabelPosition_<.5;var a,e=this.projection_.getExtent(),d=getWidth(e);this.getSource().getWrapX()&&this.projection_.canWrapX()&&!containsExtent(e,r)&&(_=Math.floor((r[0]-e[0])/d),m=Math.ceil((r[2]-e[2])/d),a=Math.abs(n)>Math.PI/2,L=L!==a);const c=getVectorContext(t);for(let l=_;l<=m;++l){let t=this.meridians_.length+this.parallels_.length,e,i,a,s;if(this.meridiansLabels_)for(i=0,a=this.meridiansLabels_.length;i<a;++i){const p=this.meridians_[i];if(n||0!==l){const g=p.clone();g.translate(l*d,0),g.rotate(-n,o),(s=this.getMeridianPoint_(g,h,i)).rotate(n,o)}else s=this.getMeridianPoint_(p,r,i);(e=this.featurePool_[t++]).setGeometry(s),e.set("graticule_label",this.meridiansLabels_[i].text),c.drawFeature(e,this.lonLabelStyle_(e))}if(this.parallelsLabels_&&(l===_&&L||l===m&&!L))for(i=0,a=this.parallels_.length;i<a;++i){const f=this.parallels_[i];if(n||0!==l){const x=f.clone();x.translate(l*d,0),x.rotate(-n,o),(s=this.getParallelPoint_(x,h,i)).rotate(n,o)}else s=this.getParallelPoint_(f,r,i);(e=this.featurePool_[t++]).setGeometry(s),e.set("graticule_label",this.parallelsLabels_[i].text),c.drawFeature(e,this.latLabelStyle_(e))}}}createGraticule_(t,e,i,a){var s=this.getInterval_(i);if(-1==s)return this.meridians_.length=0,this.parallels_.length=0,this.meridiansLabels_&&(this.meridiansLabels_.length=0),void(this.parallelsLabels_&&(this.parallelsLabels_.length=0));let l=!1;var i=this.projection_.getExtent(),n=getWidth(i),n=(this.getSource().getWrapX()&&this.projection_.canWrapX()&&!containsExtent(i,t)&&(getWidth(t)>=n?(t[0]=i[0],t[2]=i[2]):l=!0),[clamp(e[0],this.minX_,this.maxX_),clamp(e[1],this.minY_,this.maxY_)]);const r=this.toLonLatTransform_(n);isNaN(r[1])&&(r[1]=Math.abs(this.maxLat_)>=Math.abs(this.minLat_)?this.maxLat_:this.minLat_);let o=clamp(r[0],this.minLon_,this.maxLon_),h=clamp(r[1],this.minLat_,this.maxLat_);var _=this.maxLines_;let m,L,d,c,p=t;l||(p=[clamp(t[0],this.minX_,this.maxX_),clamp(t[1],this.minY_,this.maxY_),clamp(t[2],this.minX_,this.maxX_),clamp(t[3],this.minY_,this.maxY_)]);i=applyTransform(p,this.toLonLatTransform_,void 0,8);let g=i[3],f=i[2],x=i[1],b=i[0];if(l||(containsCoordinate(p,this.bottomLeft_)&&(b=this.minLon_,x=this.minLat_),containsCoordinate(p,this.bottomRight_)&&(f=this.maxLon_,x=this.minLat_),containsCoordinate(p,this.topLeft_)&&(b=this.minLon_,g=this.maxLat_),containsCoordinate(p,this.topRight_)&&(f=this.maxLon_,g=this.maxLat_),g=clamp(g,h,this.maxLat_),f=clamp(f,o,this.maxLon_),x=clamp(x,this.minLat_,h),b=clamp(b,this.minLon_,o)),o=Math.floor(o/s)*s,c=clamp(o,this.minLon_,this.maxLon_),L=this.addMeridian_(c,x,g,a,t,0),m=0,l)for(;(c-=s)>=b&&m++<_;)L=this.addMeridian_(c,x,g,a,t,L);else for(;c!=this.minLon_&&m++<_;)c=Math.max(c-s,this.minLon_),L=this.addMeridian_(c,x,g,a,t,L);if(c=clamp(o,this.minLon_,this.maxLon_),m=0,l)for(;(c+=s)<=f&&m++<_;)L=this.addMeridian_(c,x,g,a,t,L);else for(;c!=this.maxLon_&&m++<_;)c=Math.min(c+s,this.maxLon_),L=this.addMeridian_(c,x,g,a,t,L);for(this.meridians_.length=L,this.meridiansLabels_&&(this.meridiansLabels_.length=L),h=Math.floor(h/s)*s,d=clamp(h,this.minLat_,this.maxLat_),L=this.addParallel_(d,b,f,a,t,0),m=0;d!=this.minLat_&&m++<_;)d=Math.max(d-s,this.minLat_),L=this.addParallel_(d,b,f,a,t,L);for(d=clamp(h,this.minLat_,this.maxLat_),m=0;d!=this.maxLat_&&m++<_;)d=Math.min(d+s,this.maxLat_),L=this.addParallel_(d,b,f,a,t,L);this.parallels_.length=L,this.parallelsLabels_&&(this.parallelsLabels_.length=L)}getInterval_(t){var i=this.projectionCenterLonLat_[0],a=this.projectionCenterLonLat_[1];let s=-1;var l=Math.pow(this.targetSize_*t,2);const n=[],r=[];for(let t=0,e=this.intervals_.length;t<e;++t){var o=clamp(this.intervals_[t]/2,0,90),h=clamp(a,-90+o,90-o),h=(n[0]=i-o,n[1]=h-o,r[0]=i+o,r[1]=h+o,this.fromLonLatTransform_(n,n),this.fromLonLatTransform_(r,r),Math.pow(r[0]-n[0],2)+Math.pow(r[1]-n[1],2));if(h<=l)break;s=this.intervals_[t]}return s}getMeridian_(t,e,i,a,s){t=meridian(t,e,i,this.projection_,a);let l=this.meridians_[s];return l?(l.setFlatCoordinates("XY",t),l.changed()):(l=new LineString(t,"XY"),this.meridians_[s]=l),l}getMeridianPoint_(t,e,i){t=t.getFlatCoordinates();let a=1,s=t.length-1;t[a]>t[s]&&(a=s,s=1);var l=Math.max(e[1],t[a]),n=Math.min(e[3],t[s]),e=clamp(e[1]+Math.abs(e[1]-e[3])*this.lonLabelPosition_,l,n),l=t[a-1]+(t[s-1]-t[a-1])*(e-t[a])/(t[s]-t[a]);const r=this.meridiansLabels_[i].geom;return r.setCoordinates([l,e]),r}getMeridians(){return this.meridians_}getParallel_(t,e,i,a,s){t=parallel(t,e,i,this.projection_,a);let l=this.parallels_[s];return l?(l.setFlatCoordinates("XY",t),l.changed()):l=new LineString(t,"XY"),l}getParallelPoint_(t,e,i){t=t.getFlatCoordinates();let a=0,s=t.length-2;t[a]>t[s]&&(a=s,s=0);var l=Math.max(e[0],t[a]),n=Math.min(e[2],t[s]),e=clamp(e[0]+Math.abs(e[0]-e[2])*this.latLabelPosition_,l,n),l=t[a+1]+(t[s+1]-t[a+1])*(e-t[a])/(t[s]-t[a]);const r=this.parallelsLabels_[i].geom;return r.setCoordinates([e,l]),r}getParallels(){return this.parallels_}updateProjectionInfo_(t){var e=getProjection("EPSG:4326"),i=t.getWorldExtent();this.maxLat_=i[3],this.maxLon_=i[2],this.minLat_=i[1],this.minLon_=i[0];const s=getTransform(t,e);if(this.minLon_<this.maxLon_)this.toLonLatTransform_=s;else{const l=this.minLon_+this.maxLon_/2;this.maxLon_+=360,this.toLonLatTransform_=function(t,e,i){i=i||2;const a=s(t,e,i);for(let t=0,e=a.length;t<e;t+=i)a[t]<l&&(a[t]+=360);return a}}this.fromLonLatTransform_=getTransform(e,t);i=applyTransform([this.minLon_,this.minLat_,this.maxLon_,this.maxLat_],this.fromLonLatTransform_,void 0,8);this.minX_=i[0],this.maxX_=i[2],this.minY_=i[1],this.maxY_=i[3],this.bottomLeft_=this.fromLonLatTransform_([this.minLon_,this.minLat_]),this.bottomRight_=this.fromLonLatTransform_([this.maxLon_,this.minLat_]),this.topLeft_=this.fromLonLatTransform_([this.minLon_,this.maxLat_]),this.topRight_=this.fromLonLatTransform_([this.maxLon_,this.maxLat_]),this.projectionCenterLonLat_=this.toLonLatTransform_(getCenter(t.getExtent())),isNaN(this.projectionCenterLonLat_[1])&&(this.projectionCenterLonLat_[1]=Math.abs(this.maxLat_)>=Math.abs(this.minLat_)?this.maxLat_:this.minLat_),this.projection_=t}}export default Graticule;