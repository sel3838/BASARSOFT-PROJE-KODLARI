import Feature from"../Feature.js";import JSONFeature from"./JSONFeature.js";import LineString from"../geom/LineString.js";import MultiLineString from"../geom/MultiLineString.js";import MultiPoint from"../geom/MultiPoint.js";import MultiPolygon from"../geom/MultiPolygon.js";import Point from"../geom/Point.js";import Polygon from"../geom/Polygon.js";import{get as getProjection}from"../proj.js";import{transformGeometryWithOptions}from"./Feature.js";class TopoJSON extends JSONFeature{constructor(t){super(),this.layerName_=(t=t||{}).layerName,this.layers_=t.layers||null,this.dataProjection=getProjection(t.dataProjection||"EPSG:4326")}readFeaturesFromObject(n,i){if("Topology"!=n.type)return[];{let t,e=null,r=null;n.transform&&(t=n.transform,e=t.scale,r=t.translate);var a=n.arcs;t&&transformArcs(a,e,r);const c=[];var s=n.objects,l=this.layerName_;let o;for(const m in s)this.layers_&&!this.layers_.includes(m)||("GeometryCollection"===s[m].type?(o=s[m],c.push.apply(c,readFeaturesFromGeometryCollection(o,a,e,r,l,m,i))):(o=s[m],c.push(readFeatureFromGeometry(o,a,e,r,l,m,i))));return c}}readProjectionFromObject(t){return this.dataProjection}}const GEOMETRY_READERS={Point:readPointGeometry,LineString:readLineStringGeometry,Polygon:readPolygonGeometry,MultiPoint:readMultiPointGeometry,MultiLineString:readMultiLineStringGeometry,MultiPolygon:readMultiPolygonGeometry};function concatenateArcs(r,o){const n=[];var i;for(let t=0,e=r.length;t<e;++t)if(i=r[t],0<t&&n.pop(),0<=i){const a=o[i];for(let t=0,e=a.length;t<e;++t)n.push(a[t].slice(0))}else{const s=o[~i];for(let t=s.length-1;0<=t;--t)n.push(s[t].slice(0))}return n}function readPointGeometry(t,e,r){t=t.coordinates;return e&&r&&transformVertex(t,e,r),new Point(t)}function readMultiPointGeometry(t,r,o){var n=t.coordinates;if(r&&o)for(let t=0,e=n.length;t<e;++t)transformVertex(n[t],r,o);return new MultiPoint(n)}function readLineStringGeometry(t,e){t=concatenateArcs(t.arcs,e);return new LineString(t)}function readMultiLineStringGeometry(r,o){const n=[];for(let t=0,e=r.arcs.length;t<e;++t)n[t]=concatenateArcs(r.arcs[t],o);return new MultiLineString(n)}function readPolygonGeometry(r,o){const n=[];for(let t=0,e=r.arcs.length;t<e;++t)n[t]=concatenateArcs(r.arcs[t],o);return new Polygon(n)}function readMultiPolygonGeometry(r,o){const n=[];for(let t=0,e=r.arcs.length;t<e;++t){var i=r.arcs[t];const a=[];for(let t=0,e=i.length;t<e;++t)a[t]=concatenateArcs(i[t],o);n[t]=a}return new MultiPolygon(n)}function readFeaturesFromGeometryCollection(t,r,o,n,i,a,s){var l=t.geometries;const c=[];for(let t=0,e=l.length;t<e;++t)c[t]=readFeatureFromGeometry(l[t],r,o,n,i,a,s);return c}function readFeatureFromGeometry(t,e,r,o,n,i,a){let s=null;var l=t.type;if(l){const u=GEOMETRY_READERS[l];s="Point"===l||"MultiPoint"===l?u(t,r,o):u(t,e),s=transformGeometryWithOptions(s,!1,a)}const c=new Feature({geometry:s});void 0!==t.id&&c.setId(t.id);let m=t.properties;return n&&((m=m||{})[n]=i),m&&c.setProperties(m,!0),c}function transformArcs(r,o,n){for(let t=0,e=r.length;t<e;++t)transformArc(r[t],o,n)}function transformArc(r,o,n){let i=0,a=0;for(let t=0,e=r.length;t<e;++t){const s=r[t];i+=s[0],a+=s[1],s[0]=i,s[1]=a,transformVertex(s,o,n)}}function transformVertex(t,e,r){t[0]=t[0]*e[0]+r[0],t[1]=t[1]*e[1]+r[1]}export default TopoJSON;