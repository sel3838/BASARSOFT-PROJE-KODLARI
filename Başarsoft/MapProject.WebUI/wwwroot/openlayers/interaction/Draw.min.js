import Circle from"../geom/Circle.js";import Event from"../events/Event.js";import EventType from"../events/EventType.js";import Feature from"../Feature.js";import GeometryCollection from"../geom/GeometryCollection.js";import InteractionProperty from"./Property.js";import LineString from"../geom/LineString.js";import MapBrowserEvent from"../MapBrowserEvent.js";import MapBrowserEventType from"../MapBrowserEventType.js";import MultiLineString from"../geom/MultiLineString.js";import MultiPoint from"../geom/MultiPoint.js";import MultiPolygon from"../geom/MultiPolygon.js";import Point from"../geom/Point.js";import PointerInteraction from"./Pointer.js";import Polygon,{fromCircle,makeRegular}from"../geom/Polygon.js";import VectorLayer from"../layer/Vector.js";import VectorSource from"../source/Vector.js";import{FALSE,TRUE}from"../functions.js";import{always,never,noModifierKeys,shiftKeyOnly}from"../events/condition.js";import{boundingExtent,getBottomLeft,getBottomRight,getTopLeft,getTopRight}from"../extent.js";import{clamp,squaredDistance,toFixed}from"../math.js";import{createEditingStyle}from"../style/Style.js";import{distance,squaredDistance as squaredCoordinateDistance}from"../coordinate.js";import{fromUserCoordinate,getUserProjection}from"../proj.js";import{getStrideForLayout}from"../geom/SimpleGeometry.js";const DrawEventType={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class DrawEvent extends Event{constructor(e,t){super(e),this.feature=t}}function getTraceTargets(t,i){var o=[];for(let e=0;e<i.length;++e){const n=i[e];appendGeometryTraceTargets(t,n.getGeometry(),o)}return o}function getSquaredDistance(e,t){return squaredDistance(e[0],e[1],t[0],t[1])}function getCoordinate(e,t){var i=e.length;return t<0?e[t+i]:i<=t?e[t-i]:e[t]}function getCumulativeSquaredDistance(t,e,i){let o,n;n=e<i?(o=e,i):(o=i,e);var r,i=Math.ceil(o),s=Math.floor(n);if(s<i)return getSquaredDistance(interpolateCoordinate(t,o),interpolateCoordinate(t,n));let a=0;o<i&&(e=interpolateCoordinate(t,o),r=getCoordinate(t,i),a+=getSquaredDistance(e,r)),s<n&&(e=getCoordinate(t,s),r=interpolateCoordinate(t,n),a+=getSquaredDistance(e,r));for(let e=i;e<s-1;++e){var h=getCoordinate(t,e),d=getCoordinate(t,e+1);a+=getSquaredDistance(h,d)}return a}function appendGeometryTraceTargets(i,e,o){if(e instanceof LineString)appendTraceTarget(i,e.getCoordinates(),!1,o);else if(e instanceof MultiLineString){var n=e.getCoordinates();for(let e=0,t=n.length;e<t;++e)appendTraceTarget(i,n[e],!1,o)}else if(e instanceof Polygon){var r=e.getCoordinates();for(let e=0,t=r.length;e<t;++e)appendTraceTarget(i,r[e],!0,o)}else if(e instanceof MultiPolygon){var s=e.getCoordinates();for(let e=0,t=s.length;e<t;++e){var a=s[e];for(let e=0,t=a.length;e<t;++e)appendTraceTarget(i,a[e],!0,o)}}else if(e instanceof GeometryCollection){var t=e.getGeometries();for(let e=0;e<t.length;++e)appendGeometryTraceTargets(i,t[e],o)}}const sharedUpdateInfo={index:-1,endIndex:NaN};function getTraceTargetUpdate(e,o,t,i){var n=e[0],r=e[1];let s=1/0,a=-1,h=NaN;for(let e=0;e<o.targets.length;++e){var d=o.targets[e],c=d.coordinates;let t=1/0,i;for(let e=0;e<c.length-1;++e){var l=getPointSegmentRelationship(n,r,c[e],c[e+1]);l.squaredDistance<t&&(t=l.squaredDistance,i=e+l.along)}t<s&&(s=t,d.ring&&o.targetIndex===e&&(d.endIndex>d.startIndex?i<d.startIndex&&(i+=c.length):d.endIndex<d.startIndex&&i>d.startIndex&&(i-=c.length)),h=i,a=e)}var g,_,e=o.targets[a];let u=e.ring;return o.targetIndex===a&&u&&(g=interpolateCoordinate(e.coordinates,h),t=t.getPixelFromCoordinate(g),distance(t,o.startPx)>i&&(u=!1)),u&&(t=(g=e.coordinates).length,(i=e.startIndex)<(e=h)?(_=getCumulativeSquaredDistance(g,i,e),getCumulativeSquaredDistance(g,i,e-t)<_&&(h-=t)):(_=getCumulativeSquaredDistance(g,i,e),getCumulativeSquaredDistance(g,i,e+t)<_&&(h+=t))),sharedUpdateInfo.index=a,sharedUpdateInfo.endIndex=h,sharedUpdateInfo}function appendTraceTarget(e,i,o,n){var r=e[0],s=e[1];for(let e=0,t=i.length-1;e<t;++e){var a=getPointSegmentRelationship(r,s,i[e],i[e+1]);if(0===a.squaredDistance)return a=e+a.along,void n.push({coordinates:i,ring:o,startIndex:a,endIndex:a})}}const sharedRel={along:0,squaredDistance:0};function getPointSegmentRelationship(e,t,i,o){var n=i[0],i=i[1],r=o[0]-n,o=o[1]-i;let s=0,a=n,h=i;return 0==r&&0==o||(s=clamp(((e-n)*r+(t-i)*o)/(r*r+o*o),0,1),a+=r*s,h+=o*s),sharedRel.along=s,sharedRel.squaredDistance=toFixed(squaredDistance(e,t,a,h),10),sharedRel}function interpolateCoordinate(e,t){var i=e.length;let o=Math.floor(t);t-=o;o>=i?o-=i:o<0&&(o+=i);let n=o+1;n>=i&&(n-=i);var i=e[o],r=i[0],i=i[1],e=e[n];return[r+(e[0]-r)*t,i+(e[1]-i)*t]}class Draw extends PointerInteraction{constructor(e){const t=e;t.stopDown||(t.stopDown=FALSE),super(t),this.on,this.once,this.un,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=e.source||null,this.features_=e.features||null,this.snapTolerance_=e.snapTolerance||12,this.type_=e.type,this.mode_=getMode(this.type_),this.stopClick_=!!e.stopClick,this.minPoints_=e.minPoints||("Polygon"===this.mode_?3:2),this.maxPoints_="Circle"===this.mode_?2:e.maxPoints||1/0,this.finishCondition_=e.finishCondition||TRUE,this.geometryLayout_=e.geometryLayout||"XY";let i=e.geometryFunction;if(!i){const n=this.mode_;if("Circle"===n)i=function(e,t,i){const o=t||new Circle([NaN,NaN]);t=fromUserCoordinate(e[0],i),e=squaredCoordinateDistance(t,fromUserCoordinate(e[e.length-1],i)),o.setCenterAndRadius(t,Math.sqrt(e),this.geometryLayout_),t=getUserProjection();return t&&o.transform(i,t),o};else{let o;"Point"===n?o=Point:"LineString"===n?o=LineString:"Polygon"===n&&(o=Polygon),i=function(e,t,i){return t?"Polygon"===n?e[0].length?t.setCoordinates([e[0].concat([e[0][0]])],this.geometryLayout_):t.setCoordinates([],this.geometryLayout_):t.setCoordinates(e,this.geometryLayout_):t=new o(e,this.geometryLayout_),t}}}this.geometryFunction_=i,this.dragVertexDelay_=void 0!==e.dragVertexDelay?e.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=e.clickTolerance?e.clickTolerance*e.clickTolerance:36,this.overlay_=new VectorLayer({source:new VectorSource({useSpatialIndex:!1,wrapX:e.wrapX||!1}),style:e.style||getDefaultStyleFunction(),updateWhileInteracting:!0}),this.geometryName_=e.geometryName,this.condition_=e.condition||noModifierKeys,this.freehandCondition_,e.freehand?this.freehandCondition_=always:this.freehandCondition_=e.freehandCondition||shiftKeyOnly,this.traceCondition_,this.setTrace(e.trace||!1),this.traceState_={active:!1},this.traceSource_=e.traceSource||e.source||null,this.addChangeListener(InteractionProperty.ACTIVE,this.updateState_)}setTrace(e){let t;t=e?!0===e?always:e:never,this.traceCondition_=t}setMap(e){super.setMap(e),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(e){e.originalEvent.type===EventType.CONTEXTMENU&&e.originalEvent.preventDefault(),this.freehand_="Point"!==this.mode_&&this.freehandCondition_(e);let t=e.type===MapBrowserEventType.POINTERMOVE,i=!0;return!this.freehand_&&this.lastDragTime_&&e.type===MapBrowserEventType.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=e.pixel,this.shouldHandle_=!this.freehand_,t=!0):this.lastDragTime_=void 0,this.shouldHandle_&&void 0!==this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&e.type===MapBrowserEventType.POINTERDRAG&&null!==this.sketchFeature_?(this.addToDrawing_(e.coordinate),i=!1):this.freehand_&&e.type===MapBrowserEventType.POINTERDOWN?i=!1:t&&this.getPointerCount()<2?(i=e.type===MapBrowserEventType.POINTERMOVE)&&this.freehand_?(this.handlePointerMove_(e),this.shouldHandle_&&e.originalEvent.preventDefault()):("mouse"===e.originalEvent.pointerType||e.type===MapBrowserEventType.POINTERDRAG&&void 0===this.downTimeout_)&&this.handlePointerMove_(e):e.type===MapBrowserEventType.DBLCLICK&&(i=!1),super.handleEvent(e)&&i}handleDownEvent(e){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=e.pixel,this.finishCoordinate_||this.startDrawing_(e.coordinate),!0):this.condition_(e)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE,e.map,e.originalEvent,!1,e.frameState))},this.dragVertexDelay_),this.downPx_=e.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(e){if(this.traceSource_&&this.traceCondition_(e))if(this.traceState_.active)this.deactivateTrace_();else{const o=this.getMap();var t=o.getCoordinateFromPixel([e.pixel[0]-this.snapTolerance_,e.pixel[1]+this.snapTolerance_]),i=o.getCoordinateFromPixel([e.pixel[0]+this.snapTolerance_,e.pixel[1]-this.snapTolerance_]),t=boundingExtent([t,i]),i=this.traceSource_.getFeaturesInExtent(t);0!==i.length&&(t=getTraceTargets(e.coordinate,i)).length&&(this.traceState_={active:!0,startPx:e.pixel.slice(),targets:t,targetIndex:-1})}}addOrRemoveTracedCoordinates_(e,t){var i=e.startIndex<=e.endIndex;i==e.startIndex<=t?i&&t>e.endIndex||!i&&t<e.endIndex?this.addTracedCoordinates_(e,e.endIndex,t):(i&&t<e.endIndex||!i&&t>e.endIndex)&&this.removeTracedCoordinates_(t,e.endIndex):(this.removeTracedCoordinates_(e.startIndex,e.endIndex),this.addTracedCoordinates_(e,e.startIndex,t))}removeTracedCoordinates_(i,o){if(i!==o){let t=0;if(i<o){var n=Math.ceil(i);let e=Math.floor(o);e===o&&--e,t=e-n+1}else{n=Math.floor(i);let e=Math.ceil(o);e===o&&(e+=1),t=n-e+1}0<t&&this.removeLastPoints_(t)}}addTracedCoordinates_(i,e,o){if(e!==o){const r=[];if(e<o){var n=Math.ceil(e);let t=Math.floor(o);t===o&&--t;for(let e=n;e<=t;++e)r.push(getCoordinate(i.coordinates,e))}else{n=Math.floor(e);let t=Math.ceil(o);t===o&&(t+=1);for(let e=n;e>=t;--e)r.push(getCoordinate(i.coordinates,e))}r.length&&this.appendCoordinates(r)}}updateTrace_(e){const t=this.traceState_;if(t.active&&!(-1===t.targetIndex&&distance(t.startPx,e.pixel)<this.snapTolerance_)){var i=getTraceTargetUpdate(e.coordinate,t,this.getMap(),this.snapTolerance_);if(t.targetIndex!==i.index){-1!==t.targetIndex&&(o=t.targets[t.targetIndex],this.removeTracedCoordinates_(o.startIndex,o.endIndex));var o=t.targets[i.index];this.addTracedCoordinates_(o,o.startIndex,i.endIndex)}else{const n=t.targets[t.targetIndex];this.addOrRemoveTracedCoordinates_(n,i.endIndex)}t.targetIndex=i.index;const n=t.targets[t.targetIndex];n.endIndex=i.endIndex;o=interpolateCoordinate(n.coordinates,n.endIndex),i=this.getMap().getPixelFromCoordinate(o);e.coordinate=o,e.pixel=[Math.round(i[0]),Math.round(i[1])]}}handleUpEvent(e){let t=!0;var i,o;return 0===this.getPointerCount()&&(this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(e),i=this.traceState_.active,this.toggleTraceState_(e),this.shouldHandle_?((o=!this.finishCoordinate_)&&this.startDrawing_(e.coordinate),!o&&this.freehand_?this.finishDrawing():this.freehand_||o&&"Point"!==this.mode_||(this.atFinish_(e.pixel,i)?this.finishCondition_(e)&&this.finishDrawing():this.addToDrawing_(e.coordinate)),t=!1):this.freehand_&&this.abortDrawing()),!t&&this.stopClick_&&e.preventDefault(),t}handlePointerMove_(e){if(this.pointerType_=e.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){var t=this.downPx_,i=e.pixel,o=t[0]-i[0],t=t[1]-i[1],i=o*o+t*t;if(this.shouldHandle_=this.freehand_?i>this.squaredClickTolerance_:i<=this.squaredClickTolerance_,!this.shouldHandle_)return}this.finishCoordinate_?(this.updateTrace_(e),this.modifyDrawing_(e.coordinate)):this.createOrUpdateSketchPoint_(e.coordinate.slice())}atFinish_(o,t){let n=!1;if(this.sketchFeature_){let e=!1,i=[this.finishCoordinate_];var r=this.mode_;if("Point"===r?n=!0:"Circle"===r?n=2===this.sketchCoords_.length:"LineString"===r?e=!t&&this.sketchCoords_.length>this.minPoints_:"Polygon"===r&&(r=this.sketchCoords_,e=r[0].length>this.minPoints_,i=[r[0][0],r[0][r[0].length-2]],i=t?[r[0][0]]:[r[0][0],r[0][r[0].length-2]]),e){const c=this.getMap();for(let e=0,t=i.length;e<t;e++){var s=i[e],a=c.getPixelFromCoordinate(s),h=o[0]-a[0],a=o[1]-a[1],d=this.freehand_?1:this.snapTolerance_;if(n=Math.sqrt(h*h+a*a)<=d){this.finishCoordinate_=s;break}}}}return n}createOrUpdateSketchPoint_(e){if(this.sketchPoint_){const t=this.sketchPoint_.getGeometry();t.setCoordinates(e)}else this.sketchPoint_=new Feature(new Point(e)),this.updateSketchFeatures_()}createOrUpdateCustomSketchLine_(e){this.sketchLine_||(this.sketchLine_=new Feature);const t=e.getLinearRing(0);let i=this.sketchLine_.getGeometry();i?(i.setFlatCoordinates(t.getLayout(),t.getFlatCoordinates()),i.changed()):(i=new LineString(t.getFlatCoordinates(),t.getLayout()),this.sketchLine_.setGeometry(i))}startDrawing_(e){for(var t=this.getMap().getView().getProjection(),i=getStrideForLayout(this.geometryLayout_);e.length<i;)e.push(0);this.finishCoordinate_=e,"Point"===this.mode_?this.sketchCoords_=e.slice():"Polygon"===this.mode_?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new Feature(new LineString(this.sketchLineCoords_)));t=this.geometryFunction_(this.sketchCoords_,void 0,t);this.sketchFeature_=new Feature,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(t),this.updateSketchFeatures_(),this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART,this.sketchFeature_))}modifyDrawing_(e){const t=this.getMap(),i=this.sketchFeature_.getGeometry();var o=t.getView().getProjection(),n=getStrideForLayout(this.geometryLayout_);let r,s;for(;e.length<n;)e.push(0);if("Point"===this.mode_?s=this.sketchCoords_:"Polygon"===this.mode_?(r=this.sketchCoords_[0],s=r[r.length-1],this.atFinish_(t.getPixelFromCoordinate(e))&&(e=this.finishCoordinate_.slice())):(r=this.sketchCoords_,s=r[r.length-1]),s[0]=e[0],s[1]=e[1],this.geometryFunction_(this.sketchCoords_,i,o),this.sketchPoint_){const a=this.sketchPoint_.getGeometry();a.setCoordinates(e)}if("Polygon"===i.getType()&&"Polygon"!==this.mode_)this.createOrUpdateCustomSketchLine_(i);else if(this.sketchLineCoords_){const h=this.sketchLine_.getGeometry();h.setCoordinates(this.sketchLineCoords_)}this.updateSketchFeatures_()}addToDrawing_(e){var t=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let o,n;var r=this.mode_;return"LineString"===r||"Circle"===r?(this.finishCoordinate_=e.slice(),(n=this.sketchCoords_).length>=this.maxPoints_&&(this.freehand_?n.pop():o=!0),n.push(e.slice()),this.geometryFunction_(n,t,i)):"Polygon"===r&&((n=this.sketchCoords_[0]).length>=this.maxPoints_&&(this.freehand_?n.pop():o=!0),n.push(e.slice()),o&&(this.finishCoordinate_=n[0]),this.geometryFunction_(this.sketchCoords_,t,i)),this.createOrUpdateSketchPoint_(e.slice()),this.updateSketchFeatures_(),o?this.finishDrawing():this.sketchFeature_}removeLastPoints_(t){if(this.sketchFeature_){const r=this.sketchFeature_.getGeometry();var i,o=this.getMap().getView().getProjection(),n=this.mode_;for(let e=0;e<t;++e){let e;if("LineString"===n||"Circle"===n)(e=this.sketchCoords_).splice(-2,1),2<=e.length&&(this.finishCoordinate_=e[e.length-2].slice(),i=this.finishCoordinate_.slice(),e[e.length-1]=i,this.createOrUpdateSketchPoint_(i)),this.geometryFunction_(e,r,o),"Polygon"===r.getType()&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(r);else if("Polygon"===n){(e=this.sketchCoords_[0]).splice(-2,1);const s=this.sketchLine_.getGeometry();2<=e.length&&(i=e[e.length-2].slice(),e[e.length-1]=i,this.createOrUpdateSketchPoint_(i)),s.setCoordinates(e),this.geometryFunction_(this.sketchCoords_,r,o)}if(1===e.length){this.abortDrawing();break}}this.updateSketchFeatures_()}}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const e=this.abortDrawing_();if(!e)return null;let t=this.sketchCoords_;const i=e.getGeometry();var o=this.getMap().getView().getProjection();return"LineString"===this.mode_?(t.pop(),this.geometryFunction_(t,i,o)):"Polygon"===this.mode_&&(t[0].pop(),this.geometryFunction_(t,i,o),t=i.getCoordinates()),"MultiPoint"===this.type_?e.setGeometry(new MultiPoint([t])):"MultiLineString"===this.type_?e.setGeometry(new MultiLineString([t])):"MultiPolygon"===this.type_&&e.setGeometry(new MultiPolygon([t])),this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND,e)),this.features_&&this.features_.push(e),this.source_&&this.source_.addFeature(e),e}abortDrawing_(){this.finishCoordinate_=null;var e=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),e}abortDrawing(){var e=this.abortDrawing_();e&&this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT,e))}appendCoordinates(t){var e=this.mode_,i=!this.sketchFeature_;i&&this.startDrawing_(t[0]);let o;if("LineString"===e||"Circle"===e)o=this.sketchCoords_;else{if("Polygon"!==e)return;o=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[]}i&&o.shift(),o.pop();for(let e=0;e<t.length;e++)this.addToDrawing_(t[e]);e=t[t.length-1];this.sketchFeature_=this.addToDrawing_(e),this.modifyDrawing_(e)}extend(e){const t=e.getGeometry(),i=(this.sketchFeature_=e,this.sketchCoords_=t.getCoordinates(),this.sketchCoords_[this.sketchCoords_.length-1]);this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.sketchPoint_=new Feature(new Point(i)),this.updateSketchFeatures_(),this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const e=[],t=(this.sketchFeature_&&e.push(this.sketchFeature_),this.sketchLine_&&e.push(this.sketchLine_),this.sketchPoint_&&e.push(this.sketchPoint_),this.overlay_.getSource());t.clear(!0),t.addFeatures(e)}updateState_(){var e=this.getMap(),t=this.getActive();e&&t||this.abortDrawing(),this.overlay_.setMap(t?e:null)}}function getDefaultStyleFunction(){const i=createEditingStyle();return function(e,t){return i[e.getGeometry().getType()]}}function createRegularPolygon(a,h){return function(e,t,i){var o,n=fromUserCoordinate(e[0],i),e=fromUserCoordinate(e[e.length-1],i),r=Math.sqrt(squaredCoordinateDistance(n,e));t=t||fromCircle(new Circle(n),a);let s=h;h||0===h||(o=e[0]-n[0],e=e[1]-n[1],s=Math.atan2(e,o)),makeRegular(t,n,r,s);e=getUserProjection();return e&&t.transform(i,e),t}}function createBox(){return function(e,t,i){e=boundingExtent([e[0],e[e.length-1]].map(function(e){return fromUserCoordinate(e,i)})),e=[[getBottomLeft(e),getBottomRight(e),getTopRight(e),getTopLeft(e),getBottomLeft(e)]],t?t.setCoordinates(e):t=new Polygon(e),e=getUserProjection();return e&&t.transform(i,e),t}}function getMode(e){switch(e){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+e)}}export default Draw;export{DrawEvent,createRegularPolygon,createBox};