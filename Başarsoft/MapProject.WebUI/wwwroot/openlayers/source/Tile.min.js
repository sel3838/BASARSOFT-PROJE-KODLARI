import Event from"../events/Event.js";import Source from"./Source.js";import TileCache from"../TileCache.js";import TileState from"../TileState.js";import{abstract}from"../util.js";import{assert}from"../asserts.js";import{equivalent}from"../proj.js";import{getKeyZXY,withinExtentAndZ}from"../tilecoord.js";import{getForProjection as getTileGridForProjection,wrapX}from"../tilegrid.js";import{scale as scaleSize,toSize}from"../size.js";class TileSource extends Source{constructor(e){super({attributions:e.attributions,attributionsCollapsible:e.attributionsCollapsible,projection:e.projection,state:e.state,wrapX:e.wrapX,interpolate:e.interpolate}),this.on,this.once,this.un,this.opaque_=void 0!==e.opaque&&e.opaque,this.tilePixelRatio_=void 0!==e.tilePixelRatio?e.tilePixelRatio:1,this.tileGrid=void 0!==e.tileGrid?e.tileGrid:null;this.tileGrid&&toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()),[256,256]),this.tileCache=new TileCache(e.cacheSize||0),this.tmpSize=[0,0],this.key_=e.key||"",this.tileOptions={transition:e.transition,interpolate:e.interpolate},this.zDirection=e.zDirection||0}canExpireCache(){return this.tileCache.canExpireCache()}expireCache(e,t){const i=this.getTileCacheForProjection(e);i&&i.expireCache(t)}forEachLoadedTile(e,i,r,o){const s=this.getTileCacheForProjection(e);if(!s)return!1;let l=!0,n,a,c;for(let t=r.minX;t<=r.maxX;++t)for(let e=r.minY;e<=r.maxY;++e)a=getKeyZXY(i,t,e),c=!1,s.containsKey(a)&&(n=s.get(a),c=(c=n.getState()===TileState.LOADED)&&!1!==o(n)),c||(l=!1);return l}getGutterForProjection(e){return 0}getKey(){return this.key_}setKey(e){this.key_!==e&&(this.key_=e,this.changed())}getOpaque(e){return this.opaque_}getResolutions(e){const t=e?this.getTileGridForProjection(e):this.tileGrid;return t?t.getResolutions():null}getTile(e,t,i,r,o){return abstract()}getTileGrid(){return this.tileGrid}getTileGridForProjection(e){return this.tileGrid||getTileGridForProjection(e)}getTileCacheForProjection(e){var t=this.getProjection();return assert(null===t||equivalent(t,e),"A VectorTile source can only be rendered if it has a projection compatible with the view projection."),this.tileCache}getTilePixelRatio(e){return this.tilePixelRatio_}getTilePixelSize(e,t,i){const r=this.getTileGridForProjection(i);i=this.getTilePixelRatio(t),t=toSize(r.getTileSize(e),this.tmpSize);return 1==i?t:scaleSize(t,i,this.tmpSize)}getTileCoordForTileUrlFunction(e,t){t=void 0!==t?t:this.getProjection();var i=this.getTileGridForProjection(t);return this.getWrapX()&&t.isGlobal()&&(e=wrapX(i,e,t)),withinExtentAndZ(e,i)?e:null}clear(){this.tileCache.clear()}refresh(){this.clear(),super.refresh()}updateCacheSize(e,t){const i=this.getTileCacheForProjection(t);e>i.highWaterMark&&(i.highWaterMark=e)}useTile(e,t,i,r){}}class TileSourceEvent extends Event{constructor(e,t){super(e),this.tile=t}}export default TileSource;export{TileSourceEvent};