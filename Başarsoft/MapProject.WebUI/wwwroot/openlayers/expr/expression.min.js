import{ascending}from"../array.js";import{isStringColor}from"../color.js";let numTypes=0;const NoneType=0,BooleanType=1<<numTypes++,NumberType=1<<numTypes++,StringType=1<<numTypes++,ColorType=1<<numTypes++,NumberArrayType=1<<numTypes++,SizeType=1<<numTypes++,AnyType=Math.pow(2,numTypes)-1,typeNames={[BooleanType]:"boolean",[NumberType]:"number",[StringType]:"string",[ColorType]:"color",[NumberArrayType]:"number[]",[SizeType]:"size"},namedTypes=Object.keys(typeNames).map(Number).sort(ascending);function typeName(e){const r=[];for(const t of namedTypes)includesType(e,t)&&r.push(typeNames[t]);return 0===r.length?"untyped":r.length<3?r.join(" or "):r.slice(0,-1).join(", ")+", or "+r[r.length-1]}function includesType(e,r){return(e&r)===r}function overlapsType(e,r){return!!(e&r)}function isType(e,r){return e===r}class LiteralExpression{constructor(e,r){this.type=e,this.value=r}}class CallExpression{constructor(e,r,...t){this.type=e,this.operator=r,this.args=t}}function newParsingContext(){return{variables:new Set,properties:new Set,featureId:!1,geometryType:!1,style:{}}}function getTypeFromHint(e){switch(e){case"string":return StringType;case"color":return ColorType;case"number":return NumberType;case"boolean":return BooleanType;case"number[]":return NumberArrayType;default:throw new Error("Unrecognized type hint: "+e)}}function parse(r,e,t){switch(typeof r){case"boolean":return new LiteralExpression(BooleanType,r);case"number":return new LiteralExpression(t===SizeType?SizeType:NumberType,r);case"string":{let e=StringType;return isStringColor(r)&&(e|=ColorType),isType(e&t,NoneType)||(e&=t),new LiteralExpression(e,r)}}if(!Array.isArray(r))throw new Error("Expression must be an array or a primitive value");if(0===r.length)throw new Error("Empty expression");if("string"==typeof r[0])return parseCallExpression(r,e,t);for(const n of r)if("number"!=typeof n)throw new Error("Expected an array of numbers");let o=NumberArrayType;return 2===r.length?o|=SizeType:3!==r.length&&4!==r.length||(o|=ColorType),t&&(o&=t),new LiteralExpression(o,r)}const Ops={Get:"get",Var:"var",Concat:"concat",GeometryType:"geometry-type",Any:"any",All:"all",Not:"!",Resolution:"resolution",Zoom:"zoom",Time:"time",Equal:"==",NotEqual:"!=",GreaterThan:">",GreaterThanOrEqualTo:">=",LessThan:"<",LessThanOrEqualTo:"<=",Multiply:"*",Divide:"/",Add:"+",Subtract:"-",Clamp:"clamp",Mod:"%",Pow:"^",Abs:"abs",Floor:"floor",Ceil:"ceil",Round:"round",Sin:"sin",Cos:"cos",Atan:"atan",Sqrt:"sqrt",Match:"match",Between:"between",Interpolate:"interpolate",Coalesce:"coalesce",Case:"case",In:"in",Number:"number",String:"string",Array:"array",Color:"color",Id:"id",Band:"band",Palette:"palette",ToString:"to-string"},parsers={[Ops.Get]:createParser(([,e])=>void 0!==e?getTypeFromHint(e.value):AnyType,withArgsCount(1,2),withGetArgs),[Ops.Var]:createParser(([e])=>e.type,withArgsCount(1,1),withVarArgs),[Ops.Id]:createParser(NumberType|StringType,withNoArgs,usesFeatureId),[Ops.Concat]:createParser(StringType,withArgsCount(2,1/0),parseArgsOfType(AnyType)),[Ops.GeometryType]:createParser(StringType,withNoArgs,usesGeometryType),[Ops.Resolution]:createParser(NumberType,withNoArgs),[Ops.Zoom]:createParser(NumberType,withNoArgs),[Ops.Time]:createParser(NumberType,withNoArgs),[Ops.Any]:createParser(BooleanType,withArgsCount(2,1/0),parseArgsOfType(BooleanType)),[Ops.All]:createParser(BooleanType,withArgsCount(2,1/0),parseArgsOfType(BooleanType)),[Ops.Not]:createParser(BooleanType,withArgsCount(1,1),parseArgsOfType(BooleanType)),[Ops.Equal]:createParser(BooleanType,withArgsCount(2,2),parseArgsOfType(AnyType),narrowArgsType),[Ops.NotEqual]:createParser(BooleanType,withArgsCount(2,2),parseArgsOfType(AnyType),narrowArgsType),[Ops.GreaterThan]:createParser(BooleanType,withArgsCount(2,2),parseArgsOfType(AnyType),narrowArgsType),[Ops.GreaterThanOrEqualTo]:createParser(BooleanType,withArgsCount(2,2),parseArgsOfType(AnyType),narrowArgsType),[Ops.LessThan]:createParser(BooleanType,withArgsCount(2,2),parseArgsOfType(AnyType),narrowArgsType),[Ops.LessThanOrEqualTo]:createParser(BooleanType,withArgsCount(2,2),parseArgsOfType(AnyType),narrowArgsType),[Ops.Multiply]:createParser(r=>{let t=NumberType|ColorType;for(let e=0;e<r.length;e++)t&=r[e].type;return t},withArgsCount(2,1/0),parseArgsOfType(NumberType|ColorType),narrowArgsType),[Ops.Coalesce]:createParser(r=>{let t=AnyType;for(let e=1;e<r.length;e+=2)t&=r[e].type;return t&=r[r.length-1].type},withArgsCount(2,1/0),parseArgsOfType(AnyType),narrowArgsType),[Ops.Divide]:createParser(NumberType,withArgsCount(2,2),parseArgsOfType(NumberType)),[Ops.Add]:createParser(NumberType,withArgsCount(2,1/0),parseArgsOfType(NumberType)),[Ops.Subtract]:createParser(NumberType,withArgsCount(2,2),parseArgsOfType(NumberType)),[Ops.Clamp]:createParser(NumberType,withArgsCount(3,3),parseArgsOfType(NumberType)),[Ops.Mod]:createParser(NumberType,withArgsCount(2,2),parseArgsOfType(NumberType)),[Ops.Pow]:createParser(NumberType,withArgsCount(2,2),parseArgsOfType(NumberType)),[Ops.Abs]:createParser(NumberType,withArgsCount(1,1),parseArgsOfType(NumberType)),[Ops.Floor]:createParser(NumberType,withArgsCount(1,1),parseArgsOfType(NumberType)),[Ops.Ceil]:createParser(NumberType,withArgsCount(1,1),parseArgsOfType(NumberType)),[Ops.Round]:createParser(NumberType,withArgsCount(1,1),parseArgsOfType(NumberType)),[Ops.Sin]:createParser(NumberType,withArgsCount(1,1),parseArgsOfType(NumberType)),[Ops.Cos]:createParser(NumberType,withArgsCount(1,1),parseArgsOfType(NumberType)),[Ops.Atan]:createParser(NumberType,withArgsCount(1,2),parseArgsOfType(NumberType)),[Ops.Sqrt]:createParser(NumberType,withArgsCount(1,1),parseArgsOfType(NumberType)),[Ops.Match]:createParser(r=>{let t=AnyType;for(let e=2;e<r.length;e+=2)t&=r[e].type;return t&=r[r.length-1].type},withArgsCount(4,1/0),withEvenArgs,parseMatchArgs),[Ops.Between]:createParser(BooleanType,withArgsCount(3,3),parseArgsOfType(NumberType)),[Ops.Interpolate]:createParser(r=>{let t=ColorType|NumberType;for(let e=3;e<r.length;e+=2)t&=r[e].type;return t},withArgsCount(6,1/0),withEvenArgs,parseInterpolateArgs),[Ops.Case]:createParser(r=>{let t=AnyType;for(let e=1;e<r.length;e+=2)t&=r[e].type;return t&=r[r.length-1].type},withArgsCount(3,1/0),withOddArgs,parseCaseArgs),[Ops.In]:createParser(BooleanType,withArgsCount(2,2),parseInArgs),[Ops.Number]:createParser(NumberType,withArgsCount(1,1/0),parseArgsOfType(AnyType)),[Ops.String]:createParser(StringType,withArgsCount(1,1/0),parseArgsOfType(AnyType)),[Ops.Array]:createParser(e=>2===e.length?NumberArrayType|SizeType:3===e.length||4===e.length?NumberArrayType|ColorType:NumberArrayType,withArgsCount(1,1/0),parseArgsOfType(NumberType)),[Ops.Color]:createParser(ColorType,withArgsCount(1,4),parseArgsOfType(NumberType)),[Ops.Band]:createParser(NumberType,withArgsCount(1,3),parseArgsOfType(NumberType)),[Ops.Palette]:createParser(ColorType,withArgsCount(2,2),parsePaletteArgs),[Ops.ToString]:createParser(StringType,withArgsCount(1,1),parseArgsOfType(BooleanType|NumberType|StringType|ColorType))};function withGetArgs(e,r){var t=parse(e[1],r);if(!(t instanceof LiteralExpression))throw new Error("Expected a literal argument for get operation");if("string"!=typeof t.value)throw new Error("Expected a string argument for get operation");return r.properties.add(t.value),3===e.length?[t,parse(e[2],r)]:[t]}function withVarArgs(e,r,t,o){e=e[1];if("string"!=typeof e)throw new Error("Expected a string argument for var operation");if(r.variables.add(e),!("variables"in r.style)||void 0===r.style.variables[e])return[new LiteralExpression(AnyType,e)];const n=parse(r.style.variables[e],r);if(n.value=e,o&&!overlapsType(o,n.type))throw new Error(`The variable ${e} has type ${typeName(n.type)} but the following type was expected: `+typeName(o));return[n]}function usesFeatureId(e,r){r.featureId=!0}function usesGeometryType(e,r){r.geometryType=!0}function withNoArgs(e,r){var t=e[0];if(1!==e.length)throw new Error(`Expected no arguments for ${t} operation`);return[]}function withArgsCount(o,n){return function(e,r){var t=e[0],e=e.length-1;if(o===n){if(e!==o)throw new Error(`Expected ${o} argument${1===o?"":"s"} for ${t}, got `+e)}else if(e<o||n<e)throw new Error(`Expected ${n===1/0?o+" or more":o+" to "+n} arguments for ${t}, got `+e)}}function parseArgsOfType(i){return function(r,t){var o,n,p=r[0],a=r.length-1;const s=new Array(a);for(let e=0;e<a;++e){const y=parse(r[e+1],t);if(!overlapsType(i,y.type))throw o=typeName(i),n=typeName(y.type),new Error(`Unexpected type for argument ${e} of ${p} operation`+`, got ${o} but expected `+n);y.type&=i,s[e]=y}return s}}function narrowArgsType(r,t,o){var e=r[0],n=r.length-1;let p=AnyType;for(let e=0;e<o.length;++e)p&=o[e].type;if(p===NoneType)throw new Error(`No common type could be found for arguments of ${e} operation`);const a=new Array(n);for(let e=0;e<n;++e)a[e]=parse(r[e+1],t,p);return a}function withOddArgs(e,r){var t=e[0],e=e.length-1;if(e%2==0)throw new Error(`An odd amount of arguments was expected for operation ${t}, got ${JSON.stringify(e)} instead`)}function withEvenArgs(e,r){var t=e[0],e=e.length-1;if(e%2==1)throw new Error(`An even amount of arguments was expected for operation ${t}, got ${JSON.stringify(e)} instead`)}function parseMatchArgs(r,t,e,o){var n=r.length-1;let p=parse(r[1],t).type;var a=parse(r[r.length-1],t);let s=void 0!==o?o&a.type:a.type;const y=new Array(n-2);for(let e=0;e<n-2;e+=2){var i=parse(r[e+2],t),u=parse(r[e+3],t);p&=i.type,s&=u.type,y[e]=i,y[e+1]=u}o=StringType|NumberType|BooleanType;if(!overlapsType(o,p))throw new Error(`Expected an input of type ${typeName(o)} for the interpolate operation`+`, got ${typeName(p)} instead`);if(p&=o,isType(s,NoneType))throw new Error("Could not find a common output type for the following match operation: "+JSON.stringify(r));for(let e=0;e<n-2;e+=2){var l=parse(r[e+2],t,p),T=parse(r[e+3],t,s);y[e]=l,y[e+1]=T}return[parse(r[1],t,p),...y,parse(r[r.length-1],t,s)]}function parseInterpolateArgs(o,n,e,r){var t=o[1];let p;switch(t[0]){case"linear":p=1;break;case"exponential":if("number"!=typeof(p=t[1]))throw new Error("Expected a number base for exponential interpolation"+`, got ${JSON.stringify(p)} instead`);break;default:p=null}if(!p)throw new Error("Invalid interpolation type: "+JSON.stringify(t));p=parse(p,n);let a=parse(o[2],n);if(!overlapsType(NumberType,a.type))throw new Error("Expected an input of type number for the interpolate operation"+`, got ${typeName(a.type)} instead`);a=parse(o[2],n,NumberType);const s=new Array(o.length-3);for(let t=0;t<s.length;t+=2){let e=parse(o[t+3],n);if(!overlapsType(NumberType,e.type))throw new Error("Expected all stop input values in the interpolate operation to be of type number"+`, got ${typeName(e.type)} at position ${t+2} instead`);let r=parse(o[t+4],n);if(!overlapsType(NumberType|ColorType,r.type))throw new Error("Expected all stop output values in the interpolate operation to be a number or color"+`, got ${typeName(r.type)} at position ${t+3} instead`);e=parse(o[t+3],n,NumberType),r=parse(o[t+4],n,NumberType|ColorType),s[t]=e,s[t+1]=r}return[p,a,...s]}function parseCaseArgs(r,t,e,o){var n=parse(r[r.length-1],t,o);let p=void 0!==o?o&n.type:n.type;const a=new Array(r.length-1);for(let e=0;e<a.length-1;e+=2){var s=parse(r[e+1],t),y=parse(r[e+2],t,o);if(!overlapsType(BooleanType,s.type))throw new Error("Expected all conditions in the case operation to be of type boolean"+`, got ${typeName(s.type)} at position ${e} instead`);p&=y.type,a[e]=s,a[e+1]=y}if(isType(p,NoneType))throw new Error("Could not find a common output type for the following case operation: "+JSON.stringify(r));for(let e=0;e<a.length-1;e+=2)a[e+1]=parse(r[e+2],t,p);return a[a.length-1]=parse(r[r.length-1],t,p),a}function parseInArgs(e,r){let t=e[2];if(!Array.isArray(t))throw new Error('The "in" operator was provided a literal value which was not an array as second argument.');if("string"==typeof t[0]){if("literal"!==t[0])throw new Error('For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.');if(!Array.isArray(t[1]))throw new Error('The "in" operator was provided a literal value which was not an array as second argument.');t=t[1]}let o=StringType|NumberType;const n=new Array(t.length);for(let e=0;e<n.length;e++){var p=parse(t[e],r);o&=p.type,n[e]=p}if(isType(o,NoneType))throw new Error("Could not find a common type for the following in operation: "+JSON.stringify(e));return[parse(e[1],r,o),...n]}function parsePaletteArgs(e,r){var t=parse(e[1],r,NumberType);if(t.type!==NumberType)throw new Error(`The first argument of palette must be an number, got ${typeName(t.type)} instead`);var o=e[2];if(!Array.isArray(o))throw new Error("The second argument of palette must be an array");const n=new Array(o.length);for(let e=0;e<n.length;e++){var p=parse(o[e],r,ColorType);if(!(p instanceof LiteralExpression))throw new Error(`The palette color at index ${e} must be a literal value`);if(!overlapsType(p.type,ColorType))throw new Error(`The palette color at index ${e} should be of type color, got ${typeName(p.type)} instead`);n[e]=p}return[t,...n]}function createParser(a,...s){return function(r,t,o){var e=r[0];let n=[];for(let e=0;e<s.length;e++)n=s[e](r,t,n,o)||n;let p="function"==typeof a?a(n):a;if(void 0!==o){if(!overlapsType(p,o))throw new Error(`The following expression was expected to return ${typeName(o)}, but returns ${typeName(p)} instead: `+JSON.stringify(r));p&=o}if(p===NoneType)throw new Error("No matching type was found for the following expression: "+JSON.stringify(r));return new CallExpression(p,e,...n)}}function parseCallExpression(e,r,t){var o=e[0];const n=parsers[o];if(n)return n(e,r,t);throw new Error("Unknown operator: "+o)}function computeGeometryType(e){if(!e)return"";const r=e.getType();switch(r){case"Point":case"LineString":case"Polygon":return r;case"MultiPoint":case"MultiLineString":case"MultiPolygon":return r.substring(5);case"Circle":return"Polygon";case"GeometryCollection":return computeGeometryType(e.getGeometries()[0]);default:return""}}export{NoneType,BooleanType,NumberType,StringType,ColorType,NumberArrayType,SizeType,AnyType,typeName,includesType,overlapsType,isType,LiteralExpression,CallExpression,newParsingContext,parse,Ops,computeGeometryType};