import PaletteTexture from"../webgl/PaletteTexture.js";import{BooleanType,CallExpression,ColorType,NoneType,NumberArrayType,NumberType,Ops,SizeType,StringType,computeGeometryType,isType,overlapsType,parse,typeName}from"./expression.js";import{Uniforms}from"../renderer/webgl/TileLayer.js";import{asArray}from"../color.js";import{toSize}from"../size.js";function computeOperatorFunctionName(e,r){return`operator_${e}_`+Object.keys(r.functions).length}function numberToGlsl(e){const r=e.toString();return r.includes(".")?r:r+".0"}function arrayToGlsl(e){if(e.length<2||4<e.length)throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");return`vec${e.length}(${e.map(numberToGlsl).join(", ")})`}function colorToGlsl(e){var e=asArray(e),r=3<e.length?e[3]:1;return arrayToGlsl([e[0]/255*r,e[1]/255*r,e[2]/255*r,r])}function sizeToGlsl(e){return arrayToGlsl(toSize(e))}const stringToFloatMap={};let stringToFloatCounter=0;function getStringNumberEquivalent(e){return e in stringToFloatMap||(stringToFloatMap[e]=stringToFloatCounter++),stringToFloatMap[e]}function stringToGlsl(e){return numberToGlsl(getStringNumberEquivalent(e))}function uniformNameForVariable(e){return"u_var_"+e}function newCompilationContext(){return{inFragmentShader:!1,variables:{},properties:{},functions:{},bandCount:0,style:{}}}const GET_BAND_VALUE_FUNC="getBandValue",PALETTE_TEXTURE_ARRAY="u_paletteTextures";function buildExpression(e,r,t,o){e=parse(e,t,r);if(isType(e.type,NoneType))throw new Error("No matching type was found");if(overlapsType(r,e.type))return compile(e,r,o);throw t=typeName(r),o=typeName(e.type),new Error(`Expected expression to be of type ${t}, got `+o)}function createCompiler(e){return(r,t,o)=>{var n=t.args.length;const a=new Array(n);for(let e=0;e<n;++e)a[e]=compile(t.args[e],o,r);return e(a,r)}}const compilers={[Ops.Get]:(e,r)=>{var t=r.args[0].value,r=(t in e.properties||(e.properties[t]={name:t,type:r.type}),e.inFragmentShader?"v_prop_":"a_prop_");return r+t},[Ops.GeometryType]:(e,r,t)=>{var o="geometryType",e=(o in e.properties||(e.properties[o]={name:o,type:StringType,evaluator:e=>computeGeometryType(e.getGeometry())}),e.inFragmentShader?"v_prop_":"a_prop_");return e+o},[Ops.Var]:(e,r)=>{var t=r.args[0].value;return t in e.variables||(e.variables[t]={name:t,type:r.type}),uniformNameForVariable(t)},[Ops.Resolution]:()=>"u_resolution",[Ops.Zoom]:()=>"u_zoom",[Ops.Time]:()=>"u_time",[Ops.Any]:createCompiler(e=>`(${e.join(" || ")})`),[Ops.All]:createCompiler(e=>`(${e.join(" && ")})`),[Ops.Not]:createCompiler(([e])=>`(!${e})`),[Ops.Equal]:createCompiler(([e,r])=>`(${e} == ${r})`),[Ops.NotEqual]:createCompiler(([e,r])=>`(${e} != ${r})`),[Ops.GreaterThan]:createCompiler(([e,r])=>`(${e} > ${r})`),[Ops.GreaterThanOrEqualTo]:createCompiler(([e,r])=>`(${e} >= ${r})`),[Ops.LessThan]:createCompiler(([e,r])=>`(${e} < ${r})`),[Ops.LessThanOrEqualTo]:createCompiler(([e,r])=>`(${e} <= ${r})`),[Ops.Multiply]:createCompiler(e=>`(${e.join(" * ")})`),[Ops.Divide]:createCompiler(([e,r])=>`(${e} / ${r})`),[Ops.Add]:createCompiler(e=>`(${e.join(" + ")})`),[Ops.Subtract]:createCompiler(([e,r])=>`(${e} - ${r})`),[Ops.Clamp]:createCompiler(([e,r,t])=>`clamp(${e}, ${r}, ${t})`),[Ops.Mod]:createCompiler(([e,r])=>`mod(${e}, ${r})`),[Ops.Pow]:createCompiler(([e,r])=>`pow(${e}, ${r})`),[Ops.Abs]:createCompiler(([e])=>`abs(${e})`),[Ops.Floor]:createCompiler(([e])=>`floor(${e})`),[Ops.Ceil]:createCompiler(([e])=>`ceil(${e})`),[Ops.Round]:createCompiler(([e])=>`floor(${e} + 0.5)`),[Ops.Sin]:createCompiler(([e])=>`sin(${e})`),[Ops.Cos]:createCompiler(([e])=>`cos(${e})`),[Ops.Atan]:createCompiler(([e,r])=>void 0!==r?`atan(${e}, ${r})`:`atan(${e})`),[Ops.Sqrt]:createCompiler(([e])=>`sqrt(${e})`),[Ops.Match]:createCompiler(r=>{var t=r[0],o=r[r.length-1];let n=null;for(let e=r.length-3;1<=e;e-=2){var a=r[e],l=r[e+1];n=`(${t} == ${a} ? ${l} : ${n||o})`}return n}),[Ops.Between]:createCompiler(([e,r,t])=>`(${e} >= ${r} && ${e} <= ${t})`),[Ops.Interpolate]:createCompiler(([t,o,...n])=>{let a="";for(let r=0;r<n.length-2;r+=2){var l=n[r],p=a||n[r+1],i=n[r+2],s=n[r+3];let e;e=t===numberToGlsl(1)?`(${o} - ${l}) / (${i} - ${l})`:`(pow(${t}, (${o} - ${l})) - 1.0) / (pow(${t}, (${i} - ${l})) - 1.0)`,a=`mix(${p}, ${s}, clamp(${e}, 0.0, 1.0))`}return a}),[Ops.Case]:createCompiler(r=>{var t=r[r.length-1];let o=null;for(let e=r.length-3;0<=e;e-=2){var n=r[e],a=r[e+1];o=`(${n} ? ${a} : ${o||t})`}return o}),[Ops.In]:createCompiler(([e,...r],t)=>{var o=computeOperatorFunctionName("in",t);const n=[];for(let e=0;e<r.length;e+=1)n.push(`  if (inputValue == ${r[e]}) { return true; }`);return t.functions[o]=`bool ${o}(float inputValue) {
${n.join("\n")}
  return false;
}`,o+`(${e})`}),[Ops.Array]:createCompiler(e=>`vec${e.length}(${e.join(", ")})`),[Ops.Color]:createCompiler(e=>{if(1===e.length)return`vec4(vec3(${e[0]} / 255.0), 1.0)`;if(2===e.length)return`(${e[1]} * vec4(vec3(${e[0]} / 255.0), 1.0))`;const r=e.slice(0,3).map(e=>e+" / 255.0");return 3===e.length?`vec4(${r.join(", ")}, 1.0)`:`(${e[3]} * vec4(${r.join(", ")}, 1.0))`}),[Ops.Band]:createCompiler(([e,r,t],o)=>{if(!(GET_BAND_VALUE_FUNC in o.functions)){let t="";var n=o.bandCount||1;for(let r=0;r<n;r++){var a=Math.floor(r/4);let e=r%4;r===n-1&&1===e&&(e=3);a=Uniforms.TILE_TEXTURE_ARRAY+`[${a}]`;t+=`  if (band == ${r+1}.0) {
    return texture2D(${a}, v_textureCoord + vec2(dx, dy))[${e}];
  }
`}o.functions[GET_BAND_VALUE_FUNC]=`float getBandValue(float band, float xOffset, float yOffset) {
  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};
  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};
${t}
}`}return GET_BAND_VALUE_FUNC+`(${e}, ${r??"0.0"}, ${t??"0.0"})`}),[Ops.Palette]:(e,r)=>{var[r,...t]=r.args,o=t.length;const n=new Uint8Array(4*o);for(let e=0;e<t.length;e++){var a=t[e].value,a=asArray(a),l=4*e;n[l]=a[0],n[1+l]=a[1],n[2+l]=a[2],n[3+l]=255*a[3]}e.paletteTextures||(e.paletteTextures=[]);var p=`${PALETTE_TEXTURE_ARRAY}[${e.paletteTextures.length}]`,i=new PaletteTexture(p,n),i=(e.paletteTextures.push(i),compile(r,NumberType,e));return`texture2D(${p}, vec2((${i} + 0.5) / ${o}.0, 0.5))`}};function compile(e,r,t){if(e instanceof CallExpression){const o=compilers[e.operator];if(void 0===o)throw new Error("No compiler defined for this operator: "+JSON.stringify(e.operator));return o(t,e,r)}if(0<(e.type&NumberType))return numberToGlsl(e.value);if(0<(e.type&BooleanType))return e.value.toString();if(0<(e.type&StringType))return stringToGlsl(e.value.toString());if(0<(e.type&ColorType))return colorToGlsl(e.value);if(0<(e.type&NumberArrayType))return arrayToGlsl(e.value);if(0<(e.type&SizeType))return sizeToGlsl(e.value);throw new Error(`Unexpected expression ${e.value} (expected type ${typeName(r)})`)}export{numberToGlsl,arrayToGlsl,colorToGlsl,sizeToGlsl,getStringNumberEquivalent,stringToGlsl,uniformNameForVariable,newCompilationContext,PALETTE_TEXTURE_ARRAY,buildExpression};