import{ColorType,LiteralExpression,Ops,overlapsType,parse,typeName}from"./expression.js";import{fromString,lchaToRgba,normalize,rgbaToLcha,toString,withAlpha}from"../color.js";function newEvaluationContext(){return{variables:{},properties:{},resolution:NaN,featureId:null,geometryType:""}}function buildExpression(r,e,s){r=parse(r,s);if(overlapsType(e,r.type))return compileExpression(r,s);throw s=typeName(e),e=typeName(r.type),new Error(`Expected expression to be of type ${s}, got `+e)}function compileExpression(r,e){if(r instanceof LiteralExpression){if(r.type!==ColorType||"string"!=typeof r.value)return function(){return r.value};{const t=fromString(r.value);return function(){return t}}}var s=r.operator;switch(s){case Ops.Number:case Ops.String:case Ops.Coalesce:return compileAssertionExpression(r,e);case Ops.Get:case Ops.Var:return compileAccessorExpression(r,e);case Ops.Id:return r=>r.featureId;case Ops.GeometryType:return r=>r.geometryType;case Ops.Concat:{const o=r.args.map(r=>compileExpression(r,e));return e=>"".concat(...o.map(r=>r(e).toString()))}case Ops.Resolution:return r=>r.resolution;case Ops.Any:case Ops.All:case Ops.Between:case Ops.In:case Ops.Not:return compileLogicalExpression(r,e);case Ops.Equal:case Ops.NotEqual:case Ops.LessThan:case Ops.LessThanOrEqualTo:case Ops.GreaterThan:case Ops.GreaterThanOrEqualTo:return compileComparisonExpression(r,e);case Ops.Multiply:case Ops.Divide:case Ops.Add:case Ops.Subtract:case Ops.Clamp:case Ops.Mod:case Ops.Pow:case Ops.Abs:case Ops.Floor:case Ops.Ceil:case Ops.Round:case Ops.Sin:case Ops.Cos:case Ops.Atan:case Ops.Sqrt:return compileNumericExpression(r,e);case Ops.Case:return compileCaseExpression(r,e);case Ops.Match:return compileMatchExpression(r,e);case Ops.Interpolate:return compileInterpolateExpression(r,e);case Ops.ToString:return compileConvertExpression(r,e);default:throw new Error("Unsupported operator "+s)}}function compileAssertionExpression(e,s){const t=e.operator,o=e.args.length,n=new Array(o);for(let r=0;r<o;++r)n[r]=compileExpression(e.args[r],s);switch(t){case Ops.Coalesce:return e=>{for(let r=0;r<o;++r){var s=n[r](e);if(null!=s)return s}throw new Error("Expected one of the values to be non-null")};case Ops.Number:case Ops.String:return e=>{for(let r=0;r<o;++r){var s=n[r](e);if(typeof s===t)return s}throw new Error("Expected one of the values to be a "+t)};default:throw new Error("Unsupported assertion operator "+t)}}function compileAccessorExpression(r,e){const s=r.args[0].value;switch(r.operator){case Ops.Get:return r=>r.properties[s];case Ops.Var:return r=>r.variables[s];default:throw new Error("Unsupported accessor operator "+r.operator)}}function compileComparisonExpression(r,e){var s=r.operator;const t=compileExpression(r.args[0],e),o=compileExpression(r.args[1],e);switch(s){case Ops.Equal:return r=>t(r)===o(r);case Ops.NotEqual:return r=>t(r)!==o(r);case Ops.LessThan:return r=>t(r)<o(r);case Ops.LessThanOrEqualTo:return r=>t(r)<=o(r);case Ops.GreaterThan:return r=>t(r)>o(r);case Ops.GreaterThanOrEqualTo:return r=>t(r)>=o(r);default:throw new Error("Unsupported comparison operator "+s)}}function compileLogicalExpression(e,s){var r=e.operator;const t=e.args.length,o=new Array(t);for(let r=0;r<t;++r)o[r]=compileExpression(e.args[r],s);switch(r){case Ops.Any:return e=>{for(let r=0;r<t;++r)if(o[r](e))return!0;return!1};case Ops.All:return e=>{for(let r=0;r<t;++r)if(!o[r](e))return!1;return!0};case Ops.Between:return r=>{var e=o[0](r),s=o[1](r),r=o[2](r);return s<=e&&e<=r};case Ops.In:return e=>{var s=o[0](e);for(let r=1;r<t;++r)if(s===o[r](e))return!0;return!1};case Ops.Not:return r=>!o[0](r);default:throw new Error("Unsupported logical operator "+r)}}function compileNumericExpression(e,s){var r=e.operator;const t=e.args.length,o=new Array(t);for(let r=0;r<t;++r)o[r]=compileExpression(e.args[r],s);switch(r){case Ops.Multiply:return e=>{let s=1;for(let r=0;r<t;++r)s*=o[r](e);return s};case Ops.Divide:return r=>o[0](r)/o[1](r);case Ops.Add:return e=>{let s=0;for(let r=0;r<t;++r)s+=o[r](e);return s};case Ops.Subtract:return r=>o[0](r)-o[1](r);case Ops.Clamp:return r=>{var e=o[0](r),s=o[1](r);if(e<s)return s;s=o[2](r);return s<e?s:e};case Ops.Mod:return r=>o[0](r)%o[1](r);case Ops.Pow:return r=>Math.pow(o[0](r),o[1](r));case Ops.Abs:return r=>Math.abs(o[0](r));case Ops.Floor:return r=>Math.floor(o[0](r));case Ops.Ceil:return r=>Math.ceil(o[0](r));case Ops.Round:return r=>Math.round(o[0](r));case Ops.Sin:return r=>Math.sin(o[0](r));case Ops.Cos:return r=>Math.cos(o[0](r));case Ops.Atan:return 2===t?r=>Math.atan2(o[0](r),o[1](r)):r=>Math.atan(o[0](r));case Ops.Sqrt:return r=>Math.sqrt(o[0](r));default:throw new Error("Unsupported numeric operator "+r)}}function compileCaseExpression(e,s){const t=e.args.length,o=new Array(t);for(let r=0;r<t;++r)o[r]=compileExpression(e.args[r],s);return e=>{for(let r=0;r<t-1;r+=2)if(o[r](e))return o[r+1](e);return o[t-1](e)}}function compileMatchExpression(e,s){const t=e.args.length,o=new Array(t);for(let r=0;r<t;++r)o[r]=compileExpression(e.args[r],s);return e=>{var s=o[0](e);for(let r=1;r<t;r+=2)if(s===o[r](e))return o[r+1](e);return o[t-1](e)}}function compileInterpolateExpression(e,s){const i=e.args.length,u=new Array(i);for(let r=0;r<i;++r)u[r]=compileExpression(e.args[r],s);return s=>{var t=u[0](s),o=u[1](s);let n,a;for(let e=2;e<i;e+=2){var p=u[e](s);let r=u[e+1](s);var c=Array.isArray(r);if(c&&(r=withAlpha(r)),o<=p)return 2===e?r:(c?interpolateColor:interpolateNumber)(t,o,n,a,p,r);n=p,a=r}return a}}function compileConvertExpression(s,e){var r=s.operator,t=s.args.length;const o=new Array(t);for(let r=0;r<t;++r)o[r]=compileExpression(s.args[r],e);if(r!==Ops.ToString)throw new Error("Unsupported convert operator "+r);return r=>{const e=o[0](r);return s.args[0].type===ColorType?toString(e):e.toString()}}function interpolateNumber(r,e,s,t,o,n){o-=s;if(0==o)return t;e-=s;return t+(1===r?e/o:(Math.pow(r,e)-1)/(Math.pow(r,o)-1))*(n-t)}function interpolateColor(r,e,s,t,o,n){if(0==o-s)return t;var a=rgbaToLcha(t),p=rgbaToLcha(n);let c=p[2]-a[2];180<c?c-=360:c<-180&&(c+=360);p=[interpolateNumber(r,e,s,a[0],o,p[0]),interpolateNumber(r,e,s,a[1],o,p[1]),a[2]+interpolateNumber(r,e,s,0,o,c),interpolateNumber(r,e,s,t[3],o,n[3])];return normalize(lchaToRgba(p))}export{newEvaluationContext,buildExpression};