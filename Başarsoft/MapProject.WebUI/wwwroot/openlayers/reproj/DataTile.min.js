import{ERROR_THRESHOLD}from"./common.js";import DataTile,{asArrayLike,asImageLike,toArray}from"../DataTile.js";import EventType from"../events/EventType.js";import TileState from"../TileState.js";import Triangulation from"./Triangulation.js";import{calculateSourceExtentResolution,canvasPool,render as renderReprojected}from"../reproj.js";import{clamp}from"../math.js";import{createCanvasContext2D,releaseCanvas}from"../dom.js";import{getArea,getIntersection,getWidth,wrapAndSliceX}from"../extent.js";import{listen,unlistenByKey}from"../events.js";class ReprojDataTile extends DataTile{constructor(e){super({tileCoord:e.tileCoord,loader:()=>Promise.resolve(new Uint8Array(4)),interpolate:e.interpolate,transition:e.transition}),this.pixelRatio_=e.pixelRatio,this.gutter_=e.gutter,this.reprojData_=null,this.reprojError_=null,this.reprojSize_=void 0,this.sourceTileGrid_=e.sourceTileGrid,this.targetTileGrid_=e.targetTileGrid,this.wrappedTileCoord_=e.wrappedTileCoord||e.tileCoord,this.sourceTiles_=[],this.sourcesListenerKeys_=null,this.sourceZ_=0;const i=e.sourceProj;var r=i.getExtent(),t=e.sourceTileGrid.getExtent(),t=(this.clipExtent_=i.canWrapX()?t?getIntersection(r,t):r:t,this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_)),s=this.targetTileGrid_.getExtent();let a=this.sourceTileGrid_.getExtent();s=s?getIntersection(t,s):t;if(0===getArea(s))this.state=TileState.EMPTY;else{r&&(a=a?getIntersection(a,r):r);var t=this.targetTileGrid_.getResolution(this.wrappedTileCoord_[0]),o=e.targetProj,l=calculateSourceExtentResolution(i,o,s,t);if(!isFinite(l)||l<=0)this.state=TileState.EMPTY;else{var n=void 0!==e.errorThreshold?e.errorThreshold:ERROR_THRESHOLD;if(this.triangulation_=new Triangulation(i,o,s,a,l*n,t),0===this.triangulation_.getTriangles().length)this.state=TileState.EMPTY;else{this.sourceZ_=this.sourceTileGrid_.getZForResolution(l);let t=this.triangulation_.calculateSourceExtent();if(a&&(i.canWrapX()?(t[1]=clamp(t[1],a[1],a[3]),t[3]=clamp(t[3],a[1],a[3])):t=getIntersection(t,a)),getArea(t)){let o=0,l=0;i.canWrapX()&&(o=getWidth(r),l=Math.floor((t[0]-r[0])/o));const h=wrapAndSliceX(t.slice(),i,!0);h.forEach(t=>{var i=this.sourceTileGrid_.getTileRangeForExtentAndZ(t,this.sourceZ_);const r=e.getTileFunction;for(let e=i.minX;e<=i.maxX;e++)for(let t=i.minY;t<=i.maxY;t++){var s,a=r(this.sourceZ_,e,t,this.pixelRatio_);a&&(s=l*o,this.sourceTiles_.push({tile:a,offset:s}))}++l}),0===this.sourceTiles_.length&&(this.state=TileState.EMPTY)}else this.state=TileState.EMPTY}}}}getSize(){return this.reprojSize_}getData(){return this.reprojData_}getError(){return this.reprojError_}reproject_(){const d=[];if(this.sourceTiles_.forEach(e=>{const i=e.tile;if(i&&i.getState()===TileState.LOADED){var s=i.getSize(),a=this.gutter_;let t;var o=asArrayLike(i.getData()),l=(t=o||toArray(asImageLike(i.getData())),[s[0]+2*a,s[1]+2*a]),o=t instanceof Float32Array,s=l[0]*l[1];const g=o?Float32Array:Uint8Array;var n=new g(t.buffer),h=g.BYTES_PER_ELEMENT,a=h*n.length/s,c=n.byteLength/l[1],o=Math.floor(c/h/l[0]),s=s*o;let r=n;if(n.length!==s){r=new g(s);let e=0,i=0;var u=l[0]*o;for(let t=0;t<l[1];++t){for(let t=0;t<u;++t)r[e++]=n[i+t];i+=c/h}}const T=this.sourceTileGrid_.getTileCoordExtent(i.tileCoord),p=(T[0]+=e.offset,T[2]+=e.offset,this.clipExtent_?.slice());p&&(p[0]+=e.offset,p[2]+=e.offset),d.push({extent:T,clipExtent:p,data:new Uint8Array(r.buffer),dataType:g,bytesPerPixel:a,pixelSize:l})}}),(this.sourceTiles_.length=0)===d.length)this.state=TileState.ERROR;else{var e=this.wrappedTileCoord_[0],i=this.targetTileGrid_.getTileSize(e),a="number"==typeof i?i:i[0],o="number"==typeof i?i:i[1],l=this.targetTileGrid_.getResolution(e),n=this.sourceTileGrid_.getResolution(this.sourceZ_),h=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);let t,s;var c=d[0].bytesPerPixel;for(let r=Math.ceil(c/3)-1;0<=r;--r){const m=[];for(let t=0,e=d.length;t<e;++t){var u=d[t],g=u.data,T=u.pixelSize,p=T[0],T=T[1];const v=createCanvasContext2D(p,T,canvasPool);p=v.createImageData(p,T);const R=p.data;let i=3*r;for(let t=0,e=R.length;t<e;t+=4)R[t]=g[i],R[t+1]=g[i+1],R[t+2]=g[i+2],R[t+3]=255,i+=c;v.putImageData(p,0,0),m.push({extent:u.extent,clipExtent:u.clipExtent,image:v.canvas})}const S=renderReprojected(a,o,this.pixelRatio_,n,this.sourceTileGrid_.getExtent(),l,h,this.triangulation_,m,this.gutter_,!1,!1,!1);for(let t=0,e=m.length;t<e;++t){const y=m[t].image;var _=y.getContext("2d");releaseCanvas(_),canvasPool.push(_.canvas)}const x=S.getContext("2d");var f=x.getImageData(0,0,S.width,S.height),E=(releaseCanvas(x),canvasPool.push(S),t||(s=new Uint8Array(c*f.width*f.height),t=new d[0].dataType(s.buffer)),f.data);let i=3*r;for(let t=0,e=E.length;t<e;t+=4)255===E[t+3]?(s[i]=E[t],s[i+1]=E[t+1],s[i+2]=E[t+2]):(s[i]=0,s[i+1]=0,s[i+2]=0),i+=c}this.reprojData_=t,this.reprojSize_=[Math.round(a*this.pixelRatio_),Math.round(o*this.pixelRatio_)],this.state=TileState.LOADED}this.changed()}load(){if(this.state===TileState.IDLE||this.state===TileState.ERROR){this.state=TileState.LOADING,this.changed();let r=0;this.sourcesListenerKeys_=[],this.sourceTiles_.forEach(({tile:e})=>{var t=e.getState();if(t===TileState.IDLE||t===TileState.LOADING){r++;const i=listen(e,EventType.CHANGE,function(){var t=e.getState();t!=TileState.LOADED&&t!=TileState.ERROR&&t!=TileState.EMPTY||(unlistenByKey(i),0===--r&&(this.unlistenSources_(),this.reproject_()))},this);this.sourcesListenerKeys_.push(i)}}),0===r?setTimeout(this.reproject_.bind(this),0):this.sourceTiles_.forEach(function({tile:t}){t.getState()==TileState.IDLE&&t.load()})}}unlistenSources_(){this.sourcesListenerKeys_.forEach(unlistenByKey),this.sourcesListenerKeys_=null}}export default ReprojDataTile;