import MultiPoint from"./MultiPoint.js";import Polygon from"./Polygon.js";import SimpleGeometry from"./SimpleGeometry.js";import{assignClosestMultiArrayPoint,multiArrayMaxSquaredDelta}from"./flat/closest.js";import{closestSquaredDistanceXY}from"../extent.js";import{deflateMultiCoordinatesArray}from"./flat/deflate.js";import{extend}from"../array.js";import{getInteriorPointsOfMultiArray}from"./flat/interiorpoint.js";import{inflateMultiCoordinatesArray}from"./flat/inflate.js";import{intersectsLinearRingMultiArray}from"./flat/intersectsextent.js";import{linearRingssAreOriented,orientLinearRingsArray}from"./flat/orient.js";import{linearRingss as linearRingssArea}from"./flat/area.js";import{linearRingss as linearRingssCenter}from"./flat/center.js";import{linearRingssContainsXY}from"./flat/contains.js";import{quantizeMultiArray}from"./flat/simplify.js";class MultiPolygon extends SimpleGeometry{constructor(t,e,i){if(super(),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!i&&!Array.isArray(t[0])){const r=t;var s=[];const o=[];for(let t=0,e=r.length;t<e;++t){const a=r[t];var n=s.length;const l=a.getEnds();for(let t=0,e=l.length;t<e;++t)l[t]+=n;extend(s,a.getFlatCoordinates()),o.push(l)}e=(0===r.length?this:r[0]).getLayout(),t=s,i=o}void 0!==e&&i?(this.setFlatCoordinates(e,t),this.endss_=i):this.setCoordinates(t,e)}appendPolygon(i){let s;if(this.flatCoordinates){var n=this.flatCoordinates.length;extend(this.flatCoordinates,i.getFlatCoordinates());for(let t=0,e=(s=i.getEnds().slice()).length;t<e;++t)s[t]+=n}else this.flatCoordinates=i.getFlatCoordinates().slice(),s=i.getEnds().slice(),this.endss_.push();this.endss_.push(s),this.changed()}clone(){var e=this.endss_.length;const i=new Array(e);for(let t=0;t<e;++t)i[t]=this.endss_[t].slice();const t=new MultiPolygon(this.flatCoordinates.slice(),this.layout,i);return t.applyProperties(this),t}closestPointXY(t,e,i,s){return s<closestSquaredDistanceXY(this.getExtent(),t,e)?s:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,t,e,i,s))}containsXY(t,e){return linearRingssContainsXY(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t,e)}getArea(){return linearRingssArea(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)}getCoordinates(t){let e;return void 0!==t?(e=this.getOrientedFlatCoordinates().slice(),orientLinearRingsArray(e,0,this.endss_,this.stride,t)):e=this.flatCoordinates,inflateMultiCoordinatesArray(e,0,this.endss_,this.stride)}getEndss(){return this.endss_}getFlatInteriorPoints(){var t;return this.flatInteriorPointsRevision_!=this.getRevision()&&(t=linearRingssCenter(this.flatCoordinates,0,this.endss_,this.stride),this.flatInteriorPoints_=getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t),this.flatInteriorPointsRevision_=this.getRevision()),this.flatInteriorPoints_}getInteriorPoints(){return new MultiPoint(this.getFlatInteriorPoints().slice(),"XYM")}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;linearRingssAreOriented(t,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=orientLinearRingsArray(this.orientedFlatCoordinates_,0,this.endss_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(t){const e=[];var i=[];return e.length=quantizeMultiArray(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(t),e,0,i),new MultiPolygon(e,"XY",i)}getPolygon(t){if(t<0||this.endss_.length<=t)return null;let i;i=0===t?0:(e=this.endss_[t-1])[e.length-1];const s=this.endss_[t].slice();var e=s[s.length-1];if(0!==i)for(let t=0,e=s.length;t<e;++t)s[t]-=i;return new Polygon(this.flatCoordinates.slice(i,e),this.layout,s)}getPolygons(){var i=this.layout;const s=this.flatCoordinates,n=this.endss_,r=[];let o=0;for(let t=0,e=n.length;t<e;++t){const h=n[t].slice();var a=h[h.length-1];if(0!==o)for(let t=0,e=h.length;t<e;++t)h[t]-=o;var l=new Polygon(s.slice(o,a),i,h);r.push(l),o=a}return r}getType(){return"MultiPolygon"}intersectsExtent(t){return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,3),this.flatCoordinates||(this.flatCoordinates=[]);e=deflateMultiCoordinatesArray(this.flatCoordinates,0,t,this.stride,this.endss_);0===e.length?this.flatCoordinates.length=0:(t=e[e.length-1],this.flatCoordinates.length=0===t.length?0:t[t.length-1]),this.changed()}}export default MultiPolygon;