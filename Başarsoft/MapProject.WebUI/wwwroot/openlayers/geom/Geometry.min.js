import BaseObject from"../Object.js";import{abstract}from"../util.js";import{compose as composeTransform,create as createTransform}from"../transform.js";import{createEmpty,createOrUpdateEmpty,getHeight,returnOrUpdate}from"../extent.js";import{get as getProjection,getTransform}from"../proj.js";import{memoizeOne}from"../functions.js";import{transform2D}from"./flat/transform.js";const tmpTransform=createTransform();class Geometry extends BaseObject{constructor(){super(),this.extent_=createEmpty(),this.extentRevision_=-1,this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=0,this.simplifyTransformedInternal=memoizeOne((t,e,r)=>{if(!r)return this.getSimplifiedGeometry(e);const s=this.clone();return s.applyTransform(r),s.getSimplifiedGeometry(e)})}simplifyTransformed(t,e){return this.simplifyTransformedInternal(this.getRevision(),t,e)}clone(){return abstract()}closestPointXY(t,e,r,s){return abstract()}containsXY(t,e){var r=this.getClosestPoint([t,e]);return r[0]===t&&r[1]===e}getClosestPoint(t,e){return this.closestPointXY(t[0],t[1],e=e||[NaN,NaN],1/0),e}intersectsCoordinate(t){return this.containsXY(t[0],t[1])}computeExtent(t){return abstract()}getExtent(t){if(this.extentRevision_!=this.getRevision()){const t=this.computeExtent(this.extent_);(isNaN(t[0])||isNaN(t[1]))&&createOrUpdateEmpty(t),this.extentRevision_=this.getRevision()}return returnOrUpdate(this.extent_,t)}rotate(t,e){abstract()}scale(t,e,r){abstract()}simplify(t){return this.getSimplifiedGeometry(t*t)}getSimplifiedGeometry(t){return abstract()}getType(){return abstract()}applyTransform(t){abstract()}intersectsExtent(t){return abstract()}translate(t,e){abstract()}transform(t,n){const o=getProjection(t);t="tile-pixels"==o.getUnits()?function(t,e,r){var s=o.getExtent(),i=o.getWorldExtent(),s=getHeight(i)/getHeight(s);return composeTransform(tmpTransform,i[0],i[3],s,-s,0,0,0),transform2D(t,0,t.length,r,tmpTransform,e),getTransform(o,n)(t,e,r)}:getTransform(o,n);return this.applyTransform(t),this}}export default Geometry;