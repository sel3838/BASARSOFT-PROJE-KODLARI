import LineString from"./LineString.js";import SimpleGeometry from"./SimpleGeometry.js";import{arrayMaxSquaredDelta,assignClosestArrayPoint}from"./flat/closest.js";import{closestSquaredDistanceXY}from"../extent.js";import{deflateCoordinatesArray}from"./flat/deflate.js";import{douglasPeuckerArray}from"./flat/simplify.js";import{extend}from"../array.js";import{inflateCoordinatesArray}from"./flat/inflate.js";import{interpolatePoint,lineStringsCoordinateAtM}from"./flat/interpolate.js";import{intersectsLineStringArray}from"./flat/intersectsextent.js";class MultiLineString extends SimpleGeometry{constructor(t,e,i){if(super(),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(t[0]))this.setCoordinates(t,e);else if(void 0!==e&&i)this.setFlatCoordinates(e,t),this.ends_=i;else{const r=t;var s=[];const i=[];for(let t=0,e=r.length;t<e;++t){const n=r[t];extend(s,n.getFlatCoordinates()),i.push(s.length)}const e=(0===r.length?this:r[0]).getLayout();this.setFlatCoordinates(e,s),this.ends_=i}}appendLineString(t){extend(this.flatCoordinates,t.getFlatCoordinates().slice()),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){const t=new MultiLineString(this.flatCoordinates.slice(),this.layout,this.ends_.slice());return t.applyProperties(this),t}closestPointXY(t,e,i,s){return s<closestSquaredDistanceXY(this.getExtent(),t,e)?s:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),assignClosestArrayPoint(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,t,e,i,s))}getCoordinateAtM(t,e,i){return"XYM"!=this.layout&&"XYZM"!=this.layout||0===this.flatCoordinates.length?null:lineStringsCoordinateAtM(this.flatCoordinates,0,this.ends_,this.stride,t,e=void 0!==e&&e,i=void 0!==i&&i)}getCoordinates(){return inflateCoordinatesArray(this.flatCoordinates,0,this.ends_,this.stride)}getEnds(){return this.ends_}getLineString(t){return t<0||this.ends_.length<=t?null:new LineString(this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t]),this.layout)}getLineStrings(){const i=this.flatCoordinates;var s=this.ends_,r=this.layout;const n=[];let a=0;for(let t=0,e=s.length;t<e;++t){var o=s[t],l=new LineString(i.slice(a,o),r);n.push(l),a=o}return n}getFlatMidpoints(){var i=[],s=this.flatCoordinates;let r=0;var n=this.ends_,a=this.stride;for(let t=0,e=n.length;t<e;++t){var o=n[t],l=interpolatePoint(s,r,o,a,.5);extend(i,l),r=o}return i}getSimplifiedGeometryInternal(t){const e=[];var i=[];return e.length=douglasPeuckerArray(this.flatCoordinates,0,this.ends_,this.stride,t,e,0,i),new MultiLineString(e,"XY",i)}getType(){return"MultiLineString"}intersectsExtent(t){return intersectsLineStringArray(this.flatCoordinates,0,this.ends_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);e=deflateCoordinatesArray(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===e.length?0:e[e.length-1],this.changed()}}export default MultiLineString;