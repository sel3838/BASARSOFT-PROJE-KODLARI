import LRUCache from"../../structs/LRUCache.js";import ReprojDataTile from"../../reproj/DataTile.js";import ReprojTile from"../../reproj/Tile.js";import TileRange from"../../TileRange.js";import TileState from"../../TileState.js";import WebGLLayerRenderer from"./Layer.js";import{abstract,getUid}from"../../util.js";import{create as createMat4}from"../../vec/mat4.js";import{createOrUpdate as createTileCoord,getKey as getTileCoordKey}from"../../tilecoord.js";import{create as createTransform,reset as resetTransform,rotate as rotateTransform,scale as scaleTransform,translate as translateTransform}from"../../transform.js";import{descending}from"../../array.js";import{fromUserExtent}from"../../proj.js";import{getIntersection,isEmpty}from"../../extent.js";import{toSize}from"../../size.js";const Uniforms={TILE_TRANSFORM:"u_tileTransform",TRANSITION_ALPHA:"u_transitionAlpha",DEPTH:"u_depth",RENDER_EXTENT:"u_renderExtent",PATTERN_ORIGIN:"u_patternOrigin",RESOLUTION:"u_resolution",ZOOM:"u_zoom",GLOBAL_ALPHA:"u_globalAlpha",PROJECTION_MATRIX:"u_projectionMatrix",SCREEN_TO_WORLD_MATRIX:"u_screenToWorldMatrix"},empty={};function depthForZ(e){return 1/(e+2)}function newTileRepresentationLookup(){return{tileIds:new Set,representationsByZ:{}}}function lookupHasTile(e,t){return e.tileIds.has(getUid(t))}function addTileRepresentationToLookup(e,t,r){const i=e.representationsByZ;r in i||(i[r]=new Set),i[r].add(t),e.tileIds.add(getUid(t.tile))}function getRenderExtent(e,t){const r=e.layerStatesArray[e.layerIndex],i=(r.extent&&(t=getIntersection(t,fromUserExtent(r.extent,e.viewState.projection))),r.layer.getRenderSource());return i.getWrapX()||(e=i.getTileGridForProjection(e.viewState.projection).getExtent())&&(t=getIntersection(t,e)),t}function getCacheKey(e,t){return e.getKey()+","+getTileCoordKey(t)}class WebGLBaseTileLayerRenderer extends WebGLLayerRenderer{constructor(e,t){super(e,{uniforms:t.uniforms,postProcesses:t.postProcesses}),this.renderComplete=!1,this.tileTransform_=createTransform(),this.tempMat4=createMat4(),this.tempTileRange_=new TileRange(0,0,0,0),this.tempTileCoord_=createTileCoord(0,0,0),this.tempSize_=[0,0];e=void 0!==t.cacheSize?t.cacheSize:512;this.tileRepresentationCache=new LRUCache(e),this.frameState=null,this.projection_=void 0}reset(e){super.reset({uniforms:e.uniforms})}isDrawableTile_(e){const t=this.getLayer();var e=e.getState(),r=t.getUseInterimTilesOnError();return e==TileState.LOADED||e==TileState.EMPTY||e==TileState.ERROR&&!r}prepareFrameInternal(e){this.projection_?e.viewState.projection!==this.projection_&&(this.clearCache(),this.projection_=e.viewState.projection):this.projection_=e.viewState.projection;const t=this.getLayer(),r=t.getRenderSource();return!!r&&(!isEmpty(getRenderExtent(e,e.extent))&&"ready"===r.getState())}createTileRepresentation(e){return abstract()}enqueueTiles(n,e,t,s,r){var a=n.viewState;const i=this.getLayer(),l=i.getRenderSource(),p=l.getTileGridForProjection(a.projection);var c=l.getGutterForProjection(a.projection),T=getUid(l);T in n.wantedTiles||(n.wantedTiles[T]={});const d=n.wantedTiles[T],h=this.tileRepresentationCache,o=i.getMapInternal();var m=Math.max(t-r,p.getMinZoom(),p.getZForResolution(Math.min(i.getMaxResolution(),o?o.getView().getResolutionForZoom(Math.max(i.getMinZoom(),0)):p.getResolution(0)),l.zDirection));for(let o=t;o>=m;--o){var g=p.getTileRangeForExtentAndZ(e,o,this.tempTileRange_),u=p.getResolution(o);for(let i=g.minX;i<=g.maxX;++i)for(let r=g.minY;r<=g.maxY;++r){var f,R=createTileCoord(o,i,r,this.tempTileCoord_),C=getCacheKey(l,R);let e,t;h.containsKey(C)&&(e=h.get(C),t=e.tile),lookupHasTile(s,t=e&&e.tile.key===l.getKey()?t:l.getTile(o,i,r,n.pixelRatio,a.projection))||(e?this.isDrawableTile_(t)?e.setTile(t):(f=t.getInterimTile(),e.setTile(f)):(e=this.createTileRepresentation({tile:t,grid:p,helper:this.helper,gutter:c}),h.set(C,e)),addTileRepresentationToLookup(s,e,o),f=t.getKey(),d[f]=!0,t.getState()!==TileState.IDLE||n.tileQueue.isKeyQueued(f)||n.tileQueue.enqueue([t,T,p.getTileCoordCenter(R),u]))}}}beforeTilesRender(e,t){this.helper.prepareDraw(this.frameState,!t,!0)}beforeTilesMaskRender(e){return!1}renderTile(e,t,r,i,o,n,s,a,l,p,c){}renderTileMask(e,t,r,i){}drawTile_(e,t,r,i,o,n,s){var a,l,p,c,T,d,h,m,g,u,f,R;t.ready&&(R=t.tile.tileCoord,n=(a=getTileCoordKey(R))in n?n[a]:1,a=s.getResolution(r),l=toSize(s.getTileSize(r),this.tempSize_),p=s.getOrigin(r),s=s.getTileCoordExtent(R),r=n<1?-1:depthForZ(r),n<1&&(e.animate=!0),m=(c=e.viewState).center[0],g=c.center[1],h=(T=l[0]+2*i)/(d=l[1]+2*i),m=(m-p[0])/(l[0]*a),g=(p[1]-g)/(l[1]*a),u=c.resolution/a,f=R[1],R=R[2],resetTransform(this.tileTransform_),scaleTransform(this.tileTransform_,2/(e.size[0]*u/T),-2/(e.size[1]*u/T)),rotateTransform(this.tileTransform_,c.rotation),scaleTransform(this.tileTransform_,1,1/h),translateTransform(this.tileTransform_,(l[0]*(f-m)-i)/T,(l[1]*(R-g)-i)/d),this.renderTile(t,this.tileTransform_,e,o,a,l,p,s,r,i,n))}renderFrame(r){this.frameState=r,this.renderComplete=!0;var e=this.helper.getGL(),t=(this.preRender(e,r),r.viewState);const i=this.getLayer(),o=i.getRenderSource(),n=o.getTileGridForProjection(t.projection);var s=o.getGutterForProjection(t.projection);const a=getRenderExtent(r,r.extent),l=n.getZForResolution(t.resolution,o.zDirection),p=newTileRepresentationLookup(),c=i.getPreload(),T=(r.nextExtent&&(t=n.getZForResolution(t.nextResolution,o.zDirection),E=getRenderExtent(r,r.nextExtent),this.enqueueTiles(r,E,t,p,c)),this.enqueueTiles(r,a,l,p,0),0<c&&setTimeout(()=>{this.enqueueTiles(r,a,l-1,p,c-1)},0),{});var d=getUid(this),h=r.time;let m=!1;for(const w of p.representationsByZ[l]){const I=w.tile;if(!(I instanceof ReprojTile||I instanceof ReprojDataTile)||I.getState()!==TileState.EMPTY){var g=I.tileCoord;if(w.ready){var u=I.getAlpha(d,h);if(1===u){I.endTransition(d);continue}m=!0;var f=getTileCoordKey(g);T[f]=u}this.renderComplete=!1;f=this.findAltTiles_(n,g,l+1,p);if(!f){var R=n.getMinZoom();for(let e=l-1;e>=R;--e)if(this.findAltTiles_(n,g,e,p))break}}}var C=p.representationsByZ,y=Object.keys(C).map(Number).sort(descending);if(this.beforeTilesMaskRender(r))for(let e=0,t=y.length;e<t;++e){var _=y[e];for(const M of C[_]){var j=M.tile.tileCoord;getTileCoordKey(j)in T||(j=n.getTileCoordExtent(j),this.renderTileMask(M,_,j,depthForZ(_)))}}this.beforeTilesRender(r,m);for(let e=0,t=y.length;e<t;++e){var S=y[e];for(const A of C[S]){var v=A.tile.tileCoord;getTileCoordKey(v)in T||this.drawTile_(r,A,S,s,a,T,n)}}for(const O of C[l]){var x=O.tile.tileCoord;getTileCoordKey(x)in T&&this.drawTile_(r,O,l,s,a,T,n)}this.helper.finalizeDraw(r,this.dispatchPreComposeEvent,this.dispatchPostComposeEvent);var E=this.helper.getCanvas();const L=this.tileRepresentationCache;for(;L.canExpireCache();){const F=L.pop();F.dispose()}return r.postRenderFunctions.push(function(e,t){o.updateCacheSize(.1,t.viewState.projection),o.expireCache(t.viewState.projection,empty)}),this.postRender(e,r),E}findAltTiles_(e,t,i,o){var n=e.getTileRangeForTileCoordAndZ(t,i,this.tempTileRange_);if(!n)return!1;let s=!0;const a=this.tileRepresentationCache;var l=this.getLayer().getRenderSource();for(let r=n.minX;r<=n.maxX;++r)for(let t=n.minY;t<=n.maxY;++t){var p=getCacheKey(l,[i,r,t]);let e=!1;!a.containsKey(p)||(p=a.get(p)).ready&&!lookupHasTile(o,p.tile)&&(addTileRepresentationToLookup(o,p,i),e=!0),e||(s=!1)}return s}clearCache(){const e=this.tileRepresentationCache;e.forEach(e=>e.dispose()),e.clear()}removeHelper(){this.helper&&this.clearCache(),super.removeHelper()}disposeInternal(){super.disposeInternal(),delete this.frameState}}export default WebGLBaseTileLayerRenderer;export{Uniforms,newTileRepresentationLookup,getCacheKey};