import BaseVector from"../../layer/BaseVector.js";import VectorEventType from"../../source/VectorEventType.js";import ViewHint from"../../ViewHint.js";import WebGLArrayBuffer from"../../webgl/Buffer.js";import WebGLLayerRenderer from"./Layer.js";import WebGLRenderTarget from"../../webgl/RenderTarget.js";import{ARRAY_BUFFER,DYNAMIC_DRAW,ELEMENT_ARRAY_BUFFER}from"../../webgl.js";import{AttributeType,DefaultUniform}from"../../webgl/Helper.js";import{WebGLWorkerMessageType}from"../../render/webgl/constants.js";import{apply as applyTransform,create as createTransform,makeInverse as makeInverseTransform,multiply as multiplyTransform,translate as translateTransform}from"../../transform.js";import{assert}from"../../asserts.js";import{buffer,createEmpty,equals}from"../../extent.js";import{colorDecodeId,colorEncodeId}from"../../render/webgl/utils.js";import{create as createWebGLWorker}from"../../worker/webgl.js";import{fromUserCoordinate,getUserProjection}from"../../proj.js";import{getUid}from"../../util.js";import{getWorldParameters}from"./worldUtil.js";import{listen,unlistenByKey}from"../../events.js";class WebGLPointsLayerRenderer extends WebGLLayerRenderer{constructor(e,t){const r=t.uniforms||{};var s=createTransform(),e=(r[DefaultUniform.PROJECTION_MATRIX]=s,super(e,{uniforms:r,postProcesses:t.postProcesses}),this.sourceRevision_=-1,this.verticesBuffer_=new WebGLArrayBuffer(ARRAY_BUFFER,DYNAMIC_DRAW),this.indicesBuffer_=new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER,DYNAMIC_DRAW),this.vertexShader_=t.vertexShader,this.fragmentShader_=t.fragmentShader,this.program_,this.hitDetectionEnabled_=t.hitDetectionEnabled??!0,t.attributes?t.attributes.map(function(e){return{name:"a_prop_"+e.name,size:1,type:AttributeType.FLOAT}}):[]);this.attributes=[{name:"a_position",size:2,type:AttributeType.FLOAT},{name:"a_index",size:1,type:AttributeType.FLOAT}],this.hitDetectionEnabled_&&(this.attributes.push({name:"a_prop_hitColor",size:4,type:AttributeType.FLOAT}),this.attributes.push({name:"a_featureUid",size:1,type:AttributeType.FLOAT})),this.attributes.push(...e),this.customAttributes=t.attributes||[],this.previousExtent_=createEmpty(),this.currentTransform_=s,this.renderTransform_=createTransform(),this.invertRenderTransform_=createTransform(),this.renderInstructions_=new Float32Array(0),this.hitRenderTarget_,this.lastSentId=0,this.worker_=createWebGLWorker(),this.worker_.addEventListener("message",e=>{var t,r=e.data;r.type===WebGLWorkerMessageType.GENERATE_POINT_BUFFERS&&(t=r.projectionTransform,this.verticesBuffer_.fromArrayBuffer(r.vertexBuffer),this.helper.flushBufferData(this.verticesBuffer_),this.indicesBuffer_.fromArrayBuffer(r.indexBuffer),this.helper.flushBufferData(this.indicesBuffer_),this.renderTransform_=t,makeInverseTransform(this.invertRenderTransform_,this.renderTransform_),this.renderInstructions_=new Float32Array(e.data.renderInstructions),r.id===this.lastSentId&&(this.ready=!0),this.getLayer().changed())}),this.featureCache_={},this.featureCount_=0;const i=this.getLayer().getSource();this.sourceListenKeys_=[listen(i,VectorEventType.ADDFEATURE,this.handleSourceFeatureAdded_,this),listen(i,VectorEventType.CHANGEFEATURE,this.handleSourceFeatureChanged_,this),listen(i,VectorEventType.REMOVEFEATURE,this.handleSourceFeatureDelete_,this),listen(i,VectorEventType.CLEAR,this.handleSourceFeatureClear_,this)],i.forEachFeature(e=>{this.featureCache_[getUid(e)]={feature:e,properties:e.getProperties(),geometry:e.getGeometry()},this.featureCount_++})}afterHelperCreated(){this.program_=this.helper.getProgram(this.fragmentShader_,this.vertexShader_),this.hitDetectionEnabled_&&(this.hitRenderTarget_=new WebGLRenderTarget(this.helper))}handleSourceFeatureAdded_(e){const t=e.feature;this.featureCache_[getUid(t)]={feature:t,properties:t.getProperties(),geometry:t.getGeometry()},this.featureCount_++}handleSourceFeatureChanged_(e){const t=e.feature;this.featureCache_[getUid(t)]={feature:t,properties:t.getProperties(),geometry:t.getGeometry()}}handleSourceFeatureDelete_(e){e=e.feature;delete this.featureCache_[getUid(e)],this.featureCount_--}handleSourceFeatureClear_(){this.featureCache_={},this.featureCount_=0}renderFrame(e){var t=this.helper.getGL(),[r,s,i]=(this.preRender(t,e),getWorldParameters(e,this.getLayer())),r=(this.renderWorlds(e,!1,r,s,i),this.helper.finalizeDraw(e,this.dispatchPreComposeEvent,this.dispatchPostComposeEvent),this.hitDetectionEnabled_&&(this.renderWorlds(e,!0,r,s,i),this.hitRenderTarget_.clearCachedData()),this.postRender(t,e),this.helper.getCanvas());return r}prepareFrameInternal(e){const t=this.getLayer(),r=t.getSource();var s=e.viewState,i=!e.viewHints[ViewHint.ANIMATING]&&!e.viewHints[ViewHint.INTERACTING],n=!equals(this.previousExtent_,e.extent),o=this.sourceRevision_<r.getRevision();return o&&(this.sourceRevision_=r.getRevision()),i&&(n||o)&&(i=s.projection,n=s.resolution,o=t instanceof BaseVector?t.getRenderBuffer():0,s=buffer(e.extent,o*n),r.loadFeatures(s,n,i),this.rebuildBuffers_(e),this.previousExtent_=e.extent.slice()),this.helper.useProgram(this.program_,e),this.helper.prepareDraw(e),this.helper.bindBuffer(this.verticesBuffer_),this.helper.bindBuffer(this.indicesBuffer_),this.helper.enableAttributes(this.attributes),!0}rebuildBuffers_(e){var t=createTransform(),r=(this.helper.makeProjectionTransform(e,t),getUserProjection()),s=(this.hitDetectionEnabled_?7:2)+this.customAttributes.length,i=s*this.featureCount_;this.renderInstructions_&&this.renderInstructions_.length===i||(this.renderInstructions_=new Float32Array(i));let n,o;const a=[];var h,u=[];let f=-1;for(const c in this.featureCache_)if(n=this.featureCache_[c],(o=n.geometry)&&"Point"===o.getType()){r?(h=fromUserCoordinate(o.getFlatCoordinates(),e.viewState.projection),a[0]=h[0],a[1]=h[1]):(a[0]=o.getFlatCoordinates()[0],a[1]=o.getFlatCoordinates()[1]),applyTransform(t,a),this.renderInstructions_[++f]=a[0],this.renderInstructions_[++f]=a[1],this.hitDetectionEnabled_&&(h=colorEncodeId(f+5,u),this.renderInstructions_[++f]=h[0],this.renderInstructions_[++f]=h[1],this.renderInstructions_[++f]=h[2],this.renderInstructions_[++f]=h[3],this.renderInstructions_[++f]=Number(c));for(let e=0;e<this.customAttributes.length;e++){var d=this.customAttributes[e].callback(n.feature,n.properties);this.renderInstructions_[++f]=d}}const l={id:++this.lastSentId,type:WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,renderInstructions:this.renderInstructions_.buffer,customAttributesSize:s-2};l.projectionTransform=t,this.ready=!1,this.worker_.postMessage(l,[this.renderInstructions_.buffer]),this.renderInstructions_=null}forEachFeatureAtCoordinate(e,t,r,s,i){if(assert(this.hitDetectionEnabled_,"`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."),this.renderInstructions_&&this.hitDetectionEnabled_){t=applyTransform(t.coordinateToPixelTransform,e.slice()),e=this.hitRenderTarget_.readPixel(t[0]/2,t[1]/2),t=[e[0]/255,e[1]/255,e[2]/255,e[3]/255],e=colorDecodeId(t),t=this.renderInstructions_[e],e=Math.floor(t).toString();const n=this.getLayer().getSource();t=n.getFeatureByUid(e);return t?s(t,this.getLayer(),null):void 0}}renderWorlds(e,t,r,s,i){let n=r;this.helper.useProgram(this.program_,e),t&&(this.hitRenderTarget_.setSize([Math.floor(e.size[0]/2),Math.floor(e.size[1]/2)]),this.helper.prepareDrawToRenderTarget(e,this.hitRenderTarget_,!0)),this.helper.bindBuffer(this.verticesBuffer_),this.helper.bindBuffer(this.indicesBuffer_),this.helper.enableAttributes(this.attributes);do{this.helper.makeProjectionTransform(e,this.currentTransform_),translateTransform(this.currentTransform_,n*i,0),multiplyTransform(this.currentTransform_,this.invertRenderTransform_),this.helper.applyUniforms(e),this.helper.applyHitDetectionUniform(t);var o=this.indicesBuffer_.getSize();this.helper.drawElements(0,o)}while(++n<s)}disposeInternal(){this.worker_.terminate(),this.layer_=null,this.sourceListenKeys_.forEach(function(e){unlistenByKey(e)}),this.sourceListenKeys_=null,super.disposeInternal()}renderDeclutter(){}}export default WebGLPointsLayerRenderer;